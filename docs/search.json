[{"path":"https://um-kevinhe.github.io/grplasso/articles/grplasso.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction:","title":"grplasso","text":"grplasso specialized R package designed fitting penalized regression models settings involving high-dimensional grouped (clustered) effects. Unlike traditional lasso approaches treat covariates equally, grplasso distinguishes efficiently handles group structures improve computational performance. tutorial demonstrates apply grplasso practice using illustrative example datasets.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/articles/grplasso.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation:","title":"grplasso","text":"","code":"require(\"devtools\") require(\"remotes\") remotes::install_github(\"UM-KevinHe/grplasso\", ref = \"main\")"},{"path":"https://um-kevinhe.github.io/grplasso/articles/grplasso.html","id":"quick-start","dir":"Articles","previous_headings":"","what":"Quick Start:","title":"grplasso","text":"section, explore fundamental usage functions integrated current R package, providing detailed interpretation resulting values obtained functions. enhance users’ understanding R package, employ example datasets, enabling comprehensive grasp functionalities.","code":"library(grplasso) #> Error in get(paste0(generic, \".\", class), envir = get_method_env()) :  #>   object 'type_sum.accel' not found"},{"path":"https://um-kevinhe.github.io/grplasso/articles/grplasso.html","id":"generalized-linear-models-glms","dir":"Articles","previous_headings":"Quick Start:","what":"1. Generalized Linear Models (GLMs)","title":"grplasso","text":"exemplify process fitting generalized linear model, utilize “BinaryData” dataset included package. dataset consists five predictors, indicator provider information, binary outcome variable.","code":"data(BinaryData) data <- BinaryData$data Y.char <- BinaryData$Y.char # variable name of outcome variable prov.char <- BinaryData$prov.char # variable name of provider indicator Z.char <- BinaryData$Z.char # variable names of predictors head(data) #>   Y Prov.ID     Z1     Z2     Z3     Z4     Z5 #> 1 1      10 -0.006 -0.159  0.588  0.378 -1.430 #> 2 0      11  0.862 -0.162  0.243  0.503  0.549 #> 3 0      11  0.453  0.961  0.665  0.522  0.859 #> 4 1       8 -0.286  0.001  0.903  0.886 -0.324 #> 5 0      13  0.564 -0.194 -0.062 -0.792 -0.783 #> 6 1      18  0.676  1.095  2.223  1.367  1.060"},{"path":"https://um-kevinhe.github.io/grplasso/articles/grplasso.html","id":"without-grouped-covariate","dir":"Articles","previous_headings":"Quick Start: > 1. Generalized Linear Models (GLMs)","what":"Without grouped covariate","title":"grplasso","text":"pp.lasso() function employed fit generalized linear model covariate include group information. user specify regularization coefficient λ\\lambda, function automatically generates sequence λ\\lambda values default. sequence starts largest λ\\lambda, penalizes covariates zero, gradually decreases λ\\lambda allow variable selection modeling flexibility. coef() function serves provide estimates coefficients fitted model. resulting coefficient matrix structured column names correspond λ\\lambda values used modeling process. plot() function designed generate figure depicting regularization path. path illustrates behavior coefficients predictor variable regularization parameter λ\\lambda varies. visualizing regularization path, users can gain valuable insights impact different regularization strengths coefficients, aiding model interpretation selection.  predict() function utilized generate model predictions given dataset based coefficient estimates obtained fitted model. model trained using pp.lasso() function coefficients estimated, predict function can applied new data obtain predictions outcome variable. function offers various types outputs suit different analysis needs. instance, fitting penalized logistic regression model, using type = “response” provides probabilities “Y = 1” observation, type = “class” provides predicted class.","code":"fit <- pp.lasso(data, Y.char, Z.char, prov.char) coef(fit)$beta[, 1:5] #>    0.132    0.1202    0.1096    0.0998     0.091 #> Z1     0 0.0000000 0.0000000 0.0000000 0.0000000 #> Z2     0 0.0000000 0.0000000 0.0000000 0.0000000 #> Z3     0 0.1120347 0.2148847 0.3098777 0.3980465 #> Z4     0 0.0000000 0.0000000 0.0000000 0.0000000 #> Z5     0 0.0000000 0.0000000 0.0000000 0.0000000 coef(fit)$gamma[1:5, 1:5] #>        0.132     0.1202     0.1096     0.0998      0.091 #> 1 -0.2411977 -0.2939898 -0.3431091 -0.3889330 -0.4318211 #> 2 -1.9635362 -1.8742433 -1.7984115 -1.7336457 -1.6779754 #> 3 -1.2089403 -1.1883078 -1.1712888 -1.1572109 -1.1455229 #> 4 -1.9600386 -1.8922127 -1.8332183 -1.7815619 -1.7360041 #> 5 -0.5500569 -0.5698456 -0.5894538 -0.6087582 -0.6276779 plot(fit, label = TRUE) predict(fit, data, Z.char, prov.char, lambda = fit$lambda, type = \"response\")[1:5, 1:5] #>          0.132    0.1202    0.1096    0.0998     0.091 #> [1,] 0.2874999 0.2996927 0.3106971 0.3206762 0.3297643 #> [2,] 0.2051302 0.2112109 0.2163924 0.2208163 0.2246015 #> [3,] 0.2051302 0.2191951 0.2321638 0.2441339 0.2551989 #> [4,] 0.3947391 0.4208778 0.4449423 0.4671087 0.4875485 #> [5,] 0.2345694 0.2340619 0.2330311 0.2316163 0.2299295 predict(fit, data, Z.char, prov.char, lambda = 0.001, type = \"class\")[1:5] #> [1] 1 0 0 1 0"},{"path":"https://um-kevinhe.github.io/grplasso/articles/grplasso.html","id":"with-grouped-covariate","dir":"Articles","previous_headings":"Quick Start: > 1. Generalized Linear Models (GLMs)","what":"With grouped covariate","title":"grplasso","text":"utilization grp.lasso() function similar previously mentioned methods, added requirement providing group information covariates. calling function, users provide necessary group information ensure proper grouping variables regularization. However, user explicitly provide group information, grp.lasso() function automatically assume variable treated individual group . default behavior simplifies process users wish specify explicit groups, ensuring function can still applied effectively without need additional input.  Please note pp.lasso() grp.lasso() functions, parameter “prov.char” optional. event user specify provider information observations, program automatically assume observations originate health provider, resulting generation one common intercept.","code":"group <- BinaryData$group fit2 <- grp.lasso(data, Y.char, Z.char, prov.char, group = group) plot(fit2, label = T) fit.no_prov <- pp.lasso(data, Y.char, Z.char) #> Warning: Provider information not provided. All data is assumed to originate #> from a single provider! coef(fit.no_prov)$beta[, 1:5] #>    0.2513    0.2289    0.2086    0.1901    0.1732 #> Z1      0 0.0000000 0.0000000 0.0000000 0.0000000 #> Z2      0 0.0000000 0.0000000 0.0000000 0.0000000 #> Z3      0 0.1006904 0.1935559 0.2800125 0.3610722 #> Z4      0 0.0000000 0.0000000 0.0000000 0.0000000 #> Z5      0 0.0000000 0.0000000 0.0000000 0.0000000 coef(fit.no_prov)$gamma[1:5] #\"gamma\" is treated as the common intercept #>     0.2513     0.2289     0.2086     0.1901     0.1732  #> -0.5838804 -0.5896897 -0.5974013 -0.6065479 -0.6167685"},{"path":"https://um-kevinhe.github.io/grplasso/articles/grplasso.html","id":"regularization-parameter-selection-for-glm-problems","dir":"Articles","previous_headings":"Quick Start: > 1. Generalized Linear Models (GLMs)","what":"Regularization parameter selection for GLM problems","title":"grplasso","text":"optimal regularization parameter (λ\\lambda) determined cross-validation. find best λ\\lambda, users can employ either cv.pp.lasso() cv.grp.lasso() function, depending specific type model working . cross-validation functions inherit parameters required model fitting process, providing seamless straightforward experience users. default, functions utilize 10-fold cross-validation. plot() function, applied cv.pp.lasso cv.grp.lasso object, generates figure enables users assess cross-entropy loss changes varying values λ\\lambda. observing plot, users can easily identify point cross-entropy loss minimized.  Indeed, users can directly use fit$lambda.min command obtain optimal value λ\\lambda.","code":"fit <- cv.pp.lasso(data, Y.char, Z.char, prov.char, nfolds = 10) plot(fit) fit$lambda.min #> [1] 0.001259591"},{"path":"https://um-kevinhe.github.io/grplasso/articles/grplasso.html","id":"discrete-survival-models","dir":"Articles","previous_headings":"Quick Start:","what":"2. Discrete Survival Models","title":"grplasso","text":"pp.DiscSurv() function utilized fitting penalized discrete survival model. contrast current R package, function necessitate data expansion based discrete time points, resulting significant reduction memory usage convergence time required operation. DiscTime dataset, included package, comprises 5 covariates, provider information, observation time, event indicator. using dataset example illustrate utilize . pp.DiscSurv() function yields three main sets coefficients primary output. coefficients pertain covariate estimates, log-transformed baseline hazard various time points, provider effects. avoid multicollinearity problems, designate first provider reference group. Similar GLM fitting functions mentioned earlier, pp.DiscSurv() also furnished coef() function. function facilitates provision coefficient estimates within fitted penalized discrete survival model across entire sequence λ\\lambda values employed modeling procedure. Users option utilize plot() function, generates figure illustrating regularization path. visual representation showcases behavior coefficients predictor variable λ\\lambda varies.  predict() function employed generate model predictions given dataset using coefficient estimates obtained fitted model. essential note discrete time points within prediction data set must align discrete time points used model fitting. match, baseline hazard mismatches estimated accurately.","code":"data(DiscTime) data <- DiscTime$data Event.char <- DiscTime$Event.char Time.char <- DiscTime$Time.char head(data) #>   Prov.ID     Z1     Z2     Z3     Z4     Z5  time status #> 1       4 -1.298 -1.471 -1.346 -1.775 -1.241  1.03      1 #> 2       5  0.192  0.163  0.953  1.083  0.371 12.50      0 #> 3       4 -2.315 -2.038 -1.629 -2.577 -2.008  0.53      1 #> 4       1 -0.198  1.231  0.633  0.739  0.214  6.74      1 #> 5       2  0.469  0.640 -0.583  0.161  0.927 12.50      0 #> 6       4 -1.445 -1.848 -3.024 -2.117 -1.894  0.53      1 fit <- pp.DiscSurv(data, Event.char, prov.char, Z.char, Time.char) coef(fit)$beta[, 1:5] #>    0.1601     0.1458     0.1329     0.1211     0.1103 #> Z1      0 -0.1735757 -0.3325774 -0.4793679 -0.6155647 #> Z2      0  0.0000000  0.0000000  0.0000000  0.0000000 #> Z3      0  0.0000000  0.0000000  0.0000000  0.0000000 #> Z4      0  0.0000000  0.0000000  0.0000000  0.0000000 #> Z5      0  0.0000000  0.0000000  0.0000000  0.0000000 coef(fit)$gamma[, 1:5] #>       0.1601     0.1458    0.1329     0.1211     0.1103 #> 1  0.0000000  0.0000000  0.000000  0.0000000  0.0000000 #> 2 -4.5665147 -4.3516946 -4.162992 -3.9945779 -3.8425705 #> 3 -0.7478311 -0.7116142 -0.682481 -0.6580980 -0.6367834 #> 4  1.2412090  1.1456446  1.059286  0.9815198  0.9121089 #> 5 -2.3399410 -2.1966372 -2.070536 -1.9577270 -1.8555876 coef(fit)$alpha[, 1:5] #>                 0.1601    0.1458    0.1329    0.1211    0.1103 #> [Time: 0.53] -1.668065 -1.747753 -1.824209 -1.898663 -1.971909 #> [Time: 1.03] -1.480994 -1.526815 -1.571328 -1.615488 -1.659886 #> [Time: 3.92] -1.622145 -1.641556 -1.661848 -1.683563 -1.706991 #> [Time: 6.74] -1.251585 -1.257340 -1.264124 -1.272503 -1.282795 #> [Time: 12.5] -1.781635 -1.780095 -1.780526 -1.783340 -1.788771 plot(fit, label = T) predict(fit, data, Event.char, prov.char, Z.char, Time.char, lambda = fit$lambda, type = \"response\", which.lambda = fit$lambda[1])[1:5,] #>   Individual [Time: 0.53] [Time: 1.03] [Time: 3.92] [Time: 6.74] [Time: 12.5] #> 1          1    0.1586823    0.1852773           NA           NA           NA #> 2          2    0.1586823    0.1852773    0.1649092    0.2224258    0.1441013 #> 3          3    0.1586823           NA           NA           NA           NA #> 4          4    0.1586823    0.1852773    0.1649092    0.2224258           NA #> 5          5    0.1586823    0.1852773    0.1649092    0.2224258    0.1441013"},{"path":"https://um-kevinhe.github.io/grplasso/articles/grplasso.html","id":"regularization-parameter-selection-for-discrete-survival-models","dir":"Articles","previous_headings":"Quick Start: > 2. Discrete Survival Models","what":"Regularization parameter selection for discrete survival models","title":"grplasso","text":"optimal regularization parameter (λ\\lambda) determined cross-validation, utilizing cross-validation error guiding metric. Users can identify best λ\\lambda value employing cv.pp.DiscSurv() function. Users can either utilize plot() function directly access fit$lambda.min command identify optimal value λ\\lambda cross-entropy loss minimized.","code":"fit <- cv.pp.DiscSurv(data, Event.char, prov.char, Z.char, Time.char, nfolds = 10, trace.cv = T) #> Starting CV fold #1... #> Starting CV fold #2... #> Starting CV fold #3... #> Starting CV fold #4... #> Starting CV fold #5... #> Starting CV fold #6... #> Starting CV fold #7... #> Starting CV fold #8... #> Starting CV fold #9... #> Starting CV fold #10... plot(fit) fit$lambda.min #> [1] 0.00243264"},{"path":"https://um-kevinhe.github.io/grplasso/articles/grplasso.html","id":"discrete-survival-model-with-no-grouped-or-clusted-information-provided","dir":"Articles","previous_headings":"Quick Start: > 2. Discrete Survival Models","what":"Discrete survival model with no grouped (or clusted) information provided","title":"grplasso","text":"Similar GLM-related functions, present solution fitting discrete survival model without requiring provider information. approach tackles issue commonly encountered existing statistical tools used fit discrete survival models, often necessitate data expansion, leading significantly slow convergence. ease use, introduced new function called DiscSurv(), designed facilitate similar user experience pp.DiscSurv(). However, key difference lies fact DiscSurv() longer demands provider information user, meaning observations now treated originating healthcare provider. Additionally, provided cv.DiscSurv() function aid users selecting optimal λ\\lambda. Moreover, coef(), predict(), plot() functions also thoughtfully incorporated.","code":"fit <- DiscSurv(data, Event.char, Z.char, Time.char) # no provider information required coef(fit, lambda = fit$lambda)$alpha[, 1:10] #time effect #>                 0.4261    0.3882    0.3537    0.3223    0.2937    0.2676 #> [Time: 0.53] -1.979501 -1.970055 -1.977003 -1.996580 -2.025956 -2.063289 #> [Time: 1.03] -2.110213 -2.069229 -2.043936 -2.030857 -2.027098 -2.024884 #> [Time: 3.92] -2.484907 -2.418504 -2.367851 -2.329504 -2.300539 -2.271883 #> [Time: 6.74] -2.355695 -2.272311 -2.204520 -2.148985 -2.102832 -2.057118 #> [Time: 12.5] -2.958691 -2.863140 -2.784495 -2.719193 -2.664086 -2.607955 #>                 0.2438    0.2221    0.2024    0.1844 #> [Time: 0.53] -2.108335 -2.159552 -2.215497 -2.275267 #> [Time: 1.03] -2.029997 -2.041139 -2.057146 -2.077164 #> [Time: 3.92] -2.250817 -2.236107 -2.226728 -2.221906 #> [Time: 6.74] -2.019042 -1.987381 -1.961174 -1.939721 #> [Time: 12.5] -2.560084 -2.519189 -2.484282 -2.454649 coef(fit, lambda = fit$lambda)$beta[, 1:10] #covariate coefficient #>    0.4261     0.3882     0.3537     0.3223       0.2937      0.2676     0.2438 #> Z1      0 -0.1556065 -0.2988513 -0.4321738 -0.555131105 -0.62728969 -0.6971121 #> Z2      0  0.0000000  0.0000000  0.0000000  0.000000000  0.00000000  0.0000000 #> Z3      0  0.0000000  0.0000000  0.0000000  0.000000000  0.00000000  0.0000000 #> Z4      0  0.0000000  0.0000000  0.0000000  0.000000000  0.00000000  0.0000000 #> Z5      0  0.0000000  0.0000000  0.0000000 -0.003068977 -0.06697318 -0.1271421 #>        0.2221     0.2024       0.1844 #> Z1 -0.7648862 -0.8306053 -0.891723581 #> Z2  0.0000000  0.0000000  0.000000000 #> Z3  0.0000000  0.0000000 -0.005878473 #> Z4  0.0000000  0.0000000  0.000000000 #> Z5 -0.1840291 -0.2383354 -0.287531205 plot(fit, label = T) cv.fit <- cv.DiscSurv(data, Event.char, Z.char, Time.char, nfolds = 10, trace.cv = T) #> Starting CV fold #1... #> Starting CV fold #2... #> Starting CV fold #3... #> Starting CV fold #4... #> Starting CV fold #5... #> Starting CV fold #6... #> Starting CV fold #7... #> Starting CV fold #8... #> Starting CV fold #9... #> Starting CV fold #10... plot(cv.fit) predict(fit, data, Event.char, Z.char, Time.char, lambda = fit$lambda, type = \"response\", which.lambda = cv.fit$lambda.min)[1:5,] #>   Individual [Time: 0.53] [Time: 1.03] [Time: 3.92] [Time: 6.74] [Time: 12.5] #> 1          1  0.491864462   0.74764296           NA           NA           NA #> 2          2  0.009860994   0.02957994  0.041247655   0.07816691   0.05422556 #> 3          3  0.952556420           NA           NA           NA           NA #> 4          4  0.020209741   0.05938188  0.081813820   0.14938494           NA #> 5          5  0.001765611   0.00538432  0.007582723   0.01483601   0.01007986"},{"path":"https://um-kevinhe.github.io/grplasso/articles/grplasso.html","id":"stratified-cox-models","dir":"Articles","previous_headings":"Quick Start:","what":"3. Stratified Cox Models","title":"grplasso","text":"R package offers Strat.cox() cv.strat_cox() functions designed fitting penalized stratified Cox models. context intended scenario, healthcare provider considered distinct stratum. functionality Strat.cox() cv.strat_cox() extends incorporation group information among variables, achieved configuring “group” parameter. employ ContTime simulation dataset, included within package, illustrate utilization two functions. dataset encompasses five covariates, provider indicator (serves stratum information), well follow-time event indicators. Users can utilize coef() function obtain coefficient estimates covariates across complete sequence λ\\lambda values. plot() function facilitates users visualizing regularization path.  ’s important highlight prov.char parameter also discretionary. absence user input, program automatically assign observations single stratum default. Consequently, conventional Cox model employed fitting. Likewise, cv.strat_cox() function can employed cross-validation, plot() function can utilized visualize cross-validation error.","code":"data(ContTime) data <- ContTime$data head(data) #>      Prov.ID       Z1       Z2       Z3       Z4       Z5 status      time #> [1,]      11 3.431888 4.397010 3.800101 4.809899 4.049038      1 0.4984520 #> [2,]       4 2.789097 2.616714 3.401736 3.510431 3.650074      0 3.0000000 #> [3,]       9 5.451523 4.009896 5.473275 4.772835 4.708293      1 0.5987062 #> [4,]      15 2.421634 2.284766 1.747758 2.182607 1.072065      1 0.6406964 #> [5,]       9 5.827436 5.238138 5.536604 5.265083 4.735679      0 3.0000000 #> [6,]      18 2.140707 1.773304 1.792366 1.774502 3.209669      0 3.0000000 fit <- Strat.cox(data, Event.char, Z.char, Time.char, prov.char, group = c(1, 2, 2, 3, 3)) coef(fit)[, 1:5] #>    0.0394      0.0368     0.0343       0.032      0.0298 #> Z1      0 -0.01983922 -0.0390155 -0.05686517 -0.07358008 #> Z2      0  0.00000000  0.0000000  0.00000000  0.00000000 #> Z3      0  0.00000000  0.0000000  0.00000000  0.00000000 #> Z4      0  0.00000000  0.0000000  0.00000000  0.00000000 #> Z5      0  0.00000000  0.0000000  0.00000000  0.00000000 plot(fit, label = T) fit.no_stratum <- Strat.cox(data, Event.char, Z.char, Time.char) #> Warning: Provider information not provided. All data is assumed to originate #> from a single provider! coef(fit.no_stratum)[, 1:5] #>    0.1745    0.1627      0.1517     0.1415        0.132 #> Z1      0 0.0000000 0.000000000 0.00000000 0.0000000000 #> Z2      0 0.0000000 0.000000000 0.00000000 0.0005808148 #> Z3      0 0.0155369 0.025755673 0.03313948 0.0398429622 #> Z4      0 0.0000000 0.004892787 0.01173321 0.0177767495 #> Z5      0 0.0000000 0.000000000 0.00000000 0.0000000000 cv.fit <- cv.strat_cox(data, Event.char, Z.char, Time.char, prov.char, group = c(1, 2, 2, 3, 3), nfolds = 10, se = \"quick\") cv.fit$lambda.min #> [1] 0.004228925 plot(cv.fit)"},{"path":"https://um-kevinhe.github.io/grplasso/articles/Models.html","id":"generalized-linear-models","dir":"Articles","previous_headings":"","what":"Generalized Linear Models","title":"Models","text":"Let YijY_{ij} denotes outcome variable record j(j=1,...,nij \\ (j = 1, ..., n_i) center ii, let 𝐗ij\\boldsymbol{X}_{ij} corresponding 1×P1 \\times P vector risk factors. assume given linear predictor ηij:=γi+𝐗ij𝛃\\eta_{ij} := \\gamma_i +  \\boldsymbol{X}_{ij}\\boldsymbol{\\beta}, outcome YijY_{ij} follows distribution exponential family. Incorporate penalty terms, problem interest estimating 𝛉=(𝛄T,𝛃T)T\\boldsymbol{\\theta} = (\\boldsymbol{\\gamma}^T, \\boldsymbol{\\beta}^T)^T minimizing: Qλ(𝛉)=−1n∑=1m∑j=1ni{Yij(γi+𝐗ij𝛃)−b(γi+𝐗ij𝛃)}+∑p=1Pλp|βp|,Q_{\\lambda}(\\boldsymbol{\\theta}) = -\\frac{1}{n}\\sum\\limits_{= 1}^m \\sum\\limits_{j = 1}^{n_i} \\{Y_{ij}(\\gamma_i +  \\boldsymbol{X}_{ij}\\boldsymbol{\\beta}) - b(\\gamma_i +  \\boldsymbol{X}_{ij}\\boldsymbol{\\beta})\\} + \\sum_{p = 1}^P \\lambda_{p} |\\beta_p|, λp\\lambda_{p}(p=1,2,...,P)(p = 1,2,...,P) regularization parameter βp\\beta_p.","code":""},{"path":[]},{"path":"https://um-kevinhe.github.io/grplasso/articles/Models.html","id":"outer-layer-update-the-provider-effect-boldsymbolgamma","dir":"Articles","previous_headings":"Generalized Linear Models > Two-layer iterative update procedure","what":"outer layer: update the provider effect 𝛄\\boldsymbol{\\gamma}","title":"Models","text":"Given previous iteration’s estimate 𝛃\\boldsymbol{\\beta} (denoted 𝛃̃\\tilde{\\boldsymbol{\\beta}}), consider Qλ,𝛄(𝛄)∝Qλ((𝛄T,𝛃̃T)T)Q_{\\lambda, \\boldsymbol{\\gamma}}(\\boldsymbol{\\gamma}) \\propto Q_{\\lambda}((\\boldsymbol{\\gamma}^T, \\tilde{\\boldsymbol{\\beta}}^T)^T) defined Qλ,𝛄(𝛄)=−1n∑=1m∑j=1ni{Yij(γi+𝐗ij𝛃̃)−b(γi+𝐗ij𝛃̃)}. Q_{\\lambda, \\boldsymbol{\\gamma}}(\\boldsymbol{\\gamma}) = - \\frac{1}{n} \\sum\\limits_{= 1}^m \\sum\\limits_{j = 1}^{n_i} \\{Y_{ij}(\\gamma_i + \\boldsymbol{X}_{ij} \\tilde{\\boldsymbol{\\beta}}) - b(\\gamma_i + \\boldsymbol{X}_{ij} \\tilde{\\boldsymbol{\\beta}})\\}. Since score function Qλ,𝛄(𝛄)Q_{\\lambda, \\boldsymbol{\\gamma}}(\\boldsymbol{\\gamma}) separable 𝛄\\boldsymbol{\\gamma} fisher information matrix diagonal, γi\\gamma_i can updated separately using subset entire data one-step Newton procedure: γ̂=γĩ+Iλ−1(γ̃)Uλ(γ̃).\\hat{\\gamma}_i = \\tilde{\\gamma_i} + I_{\\lambda}^{-1}(\\tilde{\\gamma}_i) U_{\\lambda}(\\tilde{\\gamma}_i).","code":""},{"path":"https://um-kevinhe.github.io/grplasso/articles/Models.html","id":"inner-layer-update-the-covariate-coefficient-boldsymbolbeta","dir":"Articles","previous_headings":"Generalized Linear Models > Two-layer iterative update procedure","what":"inner layer: update the covariate coefficient 𝛃\\boldsymbol{\\beta}","title":"Models","text":"Based updated value 𝛄\\boldsymbol{\\gamma} (.e. 𝛄̂\\hat{\\boldsymbol{\\gamma}} updated previously), consider Qλ,𝛃(𝛃)=Qλ((𝛄̂T,𝛃T)T)=1nℒβ(𝛃)+∑p=1Pλp|βp|,Q_{\\lambda, \\boldsymbol{\\beta}}(\\boldsymbol{\\beta}) = Q_{\\lambda}((\\hat{\\boldsymbol{\\gamma}}^T, \\boldsymbol{\\beta}^T)^T) = \\frac{1}{n}\\mathcal{L}_{\\beta}(\\boldsymbol{\\beta}) + \\sum_{p = 1}^P \\lambda_{p} |\\beta_p|, ℒβ(𝛃)=−∑=1m∑j=1ni{Yij(γ̂+𝐗ij𝛃)−b(γ̂+𝐗ij𝛃)}\\mathcal{L}_{\\beta}(\\boldsymbol{\\beta}) = - \\sum\\limits_{= 1}^m \\sum\\limits_{j = 1}^{n_i} \\{Y_{ij}(\\hat{\\gamma}_i + \\boldsymbol{X}_{ij} \\boldsymbol{\\beta}) - b(\\hat{\\gamma}_i + \\boldsymbol{X}_{ij} \\boldsymbol{\\beta})\\}. coordinate-wise updating function 𝛃\\boldsymbol{\\beta} utilizing sub-differential calculus given : β̂p=S{∑=1m∑j=1niw̃ijXijp(Z(η̃ij)−γ̂−𝐗ij𝛃̂(−p)),nλp}∑=1m∑j=1niw̃ijXijp2,\\hat{\\beta}_p = \\frac{S\\{\\sum\\limits_{= 1}^m \\sum\\limits_{j = 1}^{n_i} \\tilde{w}_{ij} {X_{ijp}} (Z(\\tilde{\\eta}_{ij}) - \\hat{\\gamma}_i - \\boldsymbol{X}_{ij} \\hat{\\boldsymbol{\\beta}}_{(-p)}), n\\lambda_p\\}}{\\sum\\limits_{= 1}^m \\sum\\limits_{j = 1}^{n_i} \\tilde{w}_{ij} {X_{ijp}}^2}, S(Z,λ)={Z−λ,ifZ>λ0,−λ≤Z≤λZ+λ,ifZ<−λ,S(Z, \\lambda) = \\begin{cases} Z - \\lambda,\\ \\ \\text{} \\ \\ \\ Z > \\lambda \\\\ \\ \\ \\ 0, \\ \\ \\ \\ \\ \\text{} \\  -\\lambda \\leq Z \\leq \\lambda \\\\ Z + \\lambda, \\ \\ \\text{} \\ \\ \\ Z < -\\lambda \\end{cases},Z(η̃ij)=γ̂+𝐗ij𝛃̃−{ℒη″(𝛈̃)−1ℒη′(𝛈̃)}ij,Z(\\tilde{\\eta}_{ij}) = \\hat{\\gamma}_i + \\boldsymbol{X}_{ij} \\tilde{\\boldsymbol{\\beta}} -  \\{\\mathcal{L}_{\\eta}''(\\tilde{\\boldsymbol{\\eta}}) ^{-1} \\mathcal{L}_{\\eta}'(\\tilde{\\boldsymbol{\\eta}})\\}_{ij}, ω̃ij=ℒη″(𝛈̃)ij.\\tilde{\\omega}_{ij} = \\mathcal{L}_{\\eta}''(\\tilde{\\boldsymbol{\\eta}})_{ij}.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/articles/Models.html","id":"extensions-covariates-with-group-information","dir":"Articles","previous_headings":"Generalized Linear Models","what":"Extensions: Covariates with Group Information","title":"Models","text":"Let 𝐗ij\\boldsymbol{X}_{ij} 1×∑k=1Kpk1 \\times \\sum_{k = 1}^K p_k vector risk factors divided KK non-overlapping groups (pkp_k denotes length group kk). coefficients risk factors denoted 𝛃\\boldsymbol{\\beta} = (𝛃1T(\\boldsymbol{\\beta}_1^T, …, 𝛃KT)T\\boldsymbol{\\beta}_K^T)^T. Given observed data {(Yij,𝐗ij)}\\{(Y_{ij}, \\boldsymbol{X}_{ij})\\}, problem interest becomes estimating 𝛉=(𝛄T,𝛃T)T\\boldsymbol{\\theta} = (\\boldsymbol{\\gamma}^T, \\boldsymbol{\\beta}^T)^T minimizing Qλ(𝛉)=1nℒ(𝛉)+∑k=1Kλk||𝛃k||2, Q_{\\lambda}(\\boldsymbol{\\theta}) = \\frac{1}{n} \\mathcal{L}(\\boldsymbol{\\theta}) + \\sum_{k = 1}^K \\lambda_k ||\\boldsymbol{\\beta}_k||_2, ℒ(𝛉)=−∑=1m∑j=1ni{Yij(γi+∑k=1K𝐗ijk𝛃k)−b(γi+∑k=1K𝐗ijk𝛃k)}\\mathcal{L}(\\boldsymbol{\\theta}) = - \\sum\\limits_{= 1}^m \\sum\\limits_{j = 1}^{n_i} \\{Y_{ij}(\\gamma_i + \\sum_{k = 1}^K \\boldsymbol{X}_{ijk}\\boldsymbol{\\beta}_k) - b(\\gamma_i + \\sum_{k = 1}^K \\boldsymbol{X}_{ijk}\\boldsymbol{\\beta}_k)\\} loss function, ||𝛃k||2||\\boldsymbol{\\beta}_k||_2 L2L_2 norm 𝛃k\\boldsymbol{\\beta}_k. λk\\lambda_k regularization parameter group kk default λk=λpk\\lambda_k = \\lambda \\sqrt{p_k}. outer layer iteration, center effects 𝛄\\boldsymbol{\\gamma}’s updated way discussed previously. inner layer, use Majorize-Minimization (MM) algorithm improve efficiency algorithm binary outcomes. Based current value 𝛄̂\\hat{\\boldsymbol{\\gamma}}, subdifferential-based group-wise updating function objective function given 𝛃k={(||𝐳̃k||−λkv)𝐳̃k||𝐳̃k||,ifv⋅||𝐳̃k||>λk0,ifv⋅||𝐳̃k||≤λk,\\boldsymbol{\\beta}_k = \\begin{cases} (||\\tilde{\\boldsymbol{z}}_k|| - \\frac{\\lambda_k}{v}) \\frac{\\tilde{\\boldsymbol{z}}_k}{||\\tilde{\\boldsymbol{z}}_k||},   & \\text{} \\ \\ v\\cdot||\\tilde{\\boldsymbol{z}}_k|| > \\lambda_k \\\\     0,  & \\text{} \\ \\ v\\cdot||\\tilde{\\boldsymbol{z}}_k|| \\leq \\lambda_k  \\end{cases}, 𝐳̃k=1n𝐗kT(Z(𝛈̃)−𝛄̂−𝐗𝛃̃(−k))\\tilde{\\boldsymbol{z}}_k = \\frac{1}{n} {\\boldsymbol{X}_k}^T (Z(\\tilde{\\boldsymbol{\\eta}}) - \\hat{\\boldsymbol{\\gamma}} - \\boldsymbol{X} \\tilde{\\boldsymbol{\\beta}}_{(-k)}) v=0.25v = 0.25. 𝛃̃(−k)\\tilde{\\boldsymbol{\\beta}}_{(-k)} recently updated value 𝛃\\boldsymbol{\\beta} set 𝛃̃k\\tilde{\\boldsymbol{\\beta}}_k 𝟎\\boldsymbol{0}, Z(𝛈̃)=𝐘Z(\\tilde{\\boldsymbol{\\eta}}) = \\boldsymbol{Y} continuous outcome Z(𝛈̃)=𝛄̂+𝐗𝛃̃+1v(𝐘−𝐩̃)Z(\\tilde{\\boldsymbol{\\eta}}) = \\hat{\\boldsymbol{\\gamma}} + \\boldsymbol{X} \\tilde{\\boldsymbol{\\beta}} + \\frac{1}{v}(\\boldsymbol{Y} - \\tilde{\\boldsymbol{p}}) binary outcome.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/articles/Models.html","id":"discrete-survival-logistic-model","dir":"Articles","previous_headings":"","what":"Discrete Survival Logistic Model","title":"Models","text":"Let T̃ij\\tilde{T}_{ij} represent underlying uncensored failure time CijC_{ij} censoring time individual jj center ii. Let 𝐙ij\\boldsymbol{Z}_{ij} denote 1×p1 \\times p vector risk factors jthj^{th} individual center ii, Δi\\Delta_i center indicator, TijT_{ij} corresponding observed failure censor time ⋃{Tij}={t1,t2,...,tK}\\bigcup\\{T_{ij}\\} = \\{t_{1}, t_{2}, ..., t_{K}\\}, t1<t2<⋯<tKt_{1} < t_{2} < \\cdots < t_{K} discrete failure times indexed m=1,2,...,Km = 1, 2, ..., K. assume T̃ij\\tilde{T}_{ij} independent CijC_{ij} given 𝐙ij\\boldsymbol{Z}_{ij} Δi\\Delta_i. Let λ(tk;𝐙ij,Δi)=P(T̃ij=ti|T̃ij≥tk,𝐙ij,Δi)\\lambda(t_k; \\boldsymbol{Z}_{ij}, \\Delta_i) = P(\\tilde{T}_{ij} = t_i | \\tilde{T}_{ij} \\geq t_k, \\boldsymbol{Z}_{ij}, \\Delta_i) hazard individual risk factor 𝐙ij\\boldsymbol{Z}_{ij} center ii time tkt_k, let 𝒟,k\\mathcal{D}_{,k} 𝒞,k\\mathcal{C}_{,k} set indices attached individuals center ii failing censoring tkt_k, respectively. full likelihood function given L=∏k=1K∏=1m{∏j∈𝒟,k[F(tk−;𝐙ij,Δi)−F(tk;𝐙ij,Δi)]∏j∈𝒞,kF(tk;𝐙ij,Δi)}, L=\\prod_{k=1}^{K} \\prod_{=1}^{m} \\left\\{\\prod_{j \\\\mathcal{D}_{,k}} [F(t_k^-; \\boldsymbol{Z}_{ij}, \\Delta_i) - F(t_k; \\boldsymbol{Z}_{ij}, \\Delta_i)] \\prod_{j \\\\mathcal{C}_{,k}} F(t_k; \\boldsymbol{Z}_{ij}, \\Delta_i)\\right\\}, F(tk;𝐙ij,Δi)=P(T̃ij>tk|𝐙ij,Δi)=∏l∣tl≤tk{1−λ(tl;𝐙ij,Δi)}F(t_k; \\boldsymbol{Z}_{ij}, \\Delta_i) = P(\\tilde{T}_{ij} > t_k|\\boldsymbol{Z}_{ij}, \\Delta_i) = \\prod\\limits_{l \\mid t_{l} \\leq t_k}\\{1 - \\lambda(t_l; \\boldsymbol{Z}_{ij}, \\Delta_i)\\} survival function time tkt_k corresponding individual center ii covariate 𝐙ij\\boldsymbol{Z}_{ij}. Let λ0(tk)\\lambda_0(t_k) discrete baseline hazard function time tkt_k, hazard relationship discrete-time logistic model defined : log(λ(tk;𝐙ij,Δi)1−λ(tk;𝐙ij,Δi))=log(λ0(tk)1−λ0(tk))+γi+𝐙ij𝛃.log(\\frac{\\lambda(t_k; \\boldsymbol{Z}_{ij}, \\Delta_i)}{1 - \\lambda(t_k; \\boldsymbol{Z}_{ij}, \\Delta_i)}) = log(\\frac{\\lambda_0(t_k)}{1 - \\lambda_0(t_k)}) + \\gamma_i + \\boldsymbol{Z}_{ij} \\boldsymbol{\\beta}. Let αk=log(λ0(tk)1−λ0(tk))\\alpha_k = log(\\frac{\\lambda_0(t_k)}{1 - \\lambda_0(t_k)}), problem interest estimating 𝛉=(𝛂𝐓,𝛄T,𝛃T)T\\boldsymbol{\\theta} = (\\boldsymbol{\\boldsymbol{\\alpha}^T, \\gamma}^T, \\boldsymbol{\\beta}^T)^T minimizing: Qλ(𝛉)=−1n∑=1m∑j=1ni∑k=1kij{δij(tk)⋅(αk+γi+𝐙ij𝛃)−log(1+eαk+γi+𝐙ij𝛃)}+∑p=1Pλp|βp|Q_{\\lambda}(\\boldsymbol{\\theta}) = -\\frac{1}{n} \\sum_{= 1}^m \\sum_{j=1}^{n_i} \\sum_{k=1}^{k_{ij}} \\{\\delta_{ij}\\left(t_{k}\\right) \\cdot (\\alpha_k + \\gamma_i + \\boldsymbol{Z}_{ij} \\boldsymbol{\\beta}) -log(1 + e^{\\alpha_k + \\gamma_i + \\boldsymbol{Z}_{ij} \\boldsymbol{\\beta}}) \\} + \\sum_{p = 1}^P \\lambda_{p} |\\beta_p|","code":""},{"path":[]},{"path":"https://um-kevinhe.github.io/grplasso/articles/Models.html","id":"outer-layer-update-the-log-transformed-baseline-hazard-boldsymbolalpha","dir":"Articles","previous_headings":"Discrete Survival Logistic Model > Three-layer iterative update procedure","what":"outer layer: update the log-transformed baseline hazard 𝛂\\boldsymbol{\\alpha}","title":"Models","text":"Given previous iteration’s estimate center effect 𝛄̃\\tilde{\\boldsymbol{\\gamma}} coefficient risk factors 𝛃̃\\tilde{\\boldsymbol{\\beta}}, consider Qλ,𝛂(𝛂)=−1n∑=1m∑j=1ni∑k=1kij{δij(tk)⋅(αk+γ̃+𝐙ij𝛃̃)−log(1+eαk+γ̃+𝐙ij𝛃̃)}Q_{\\lambda, \\boldsymbol{\\alpha}}(\\boldsymbol{\\alpha}) = - \\frac{1}{n} \\sum\\limits_{= 1}^m \\sum\\limits_{j=1}^{n_i} \\sum\\limits_{k=1}^{k_{ij}} \\{\\delta_{ij}\\left(t_{k}\\right) \\cdot (\\alpha_k + \\tilde{\\gamma}_{} +  \\boldsymbol{Z}_{ij} \\tilde{\\boldsymbol{\\beta}}) -log(1 + e^{\\alpha_k + \\tilde{\\gamma}_{} +  \\boldsymbol{Z}_{ij} \\tilde{\\boldsymbol{\\beta}}}) \\}. Newton method allows us update 𝛄\\boldsymbol{\\gamma} separately : α̂k=α̃k+Iλ−1(α̃k)Uλ(α̃k),\\hat{\\alpha}_k = \\tilde{\\alpha}_k + I_{\\lambda}^{-1}(\\tilde{\\alpha}_k) U_{\\lambda}(\\tilde{\\alpha}_k), α̃k\\tilde{\\alpha}_k current value αk\\alpha_k, $$U_{\\lambda}(\\tilde{\\alpha}_k) = - \\frac{1}{n} \\sum_{= 1}^m \\{\\sum_{j = 1}^{n_i} \\delta_{ij} \\left(t_{k}\\right) - \\sum_{j|T_{ij} \\geq t_k} \\frac{e^{\\tilde{\\alpha}_k + \\tilde{\\gamma}_i +  \\boldsymbol{Z}_{ij} \\tilde{\\boldsymbol{\\beta}}}}{1 + e^{\\tilde{\\alpha}_k + \\tilde{\\gamma}_i +  \\boldsymbol{Z}_{ij} \\tilde{\\boldsymbol{\\beta}}}}\\} \\\\      I_{\\lambda}(\\tilde{\\alpha}_k) = - \\frac{1}{n} \\sum_{= 1}^m \\sum_{j|T_{ij} \\geq t_k} \\frac{e^{\\tilde{\\alpha}_k + \\tilde{\\gamma}_i +  \\boldsymbol{Z}_{ij} \\tilde{\\boldsymbol{\\beta}}}}{(1 + e^{\\tilde{\\alpha}_k + \\tilde{\\gamma}_i +  \\boldsymbol{Z}_{ij} \\tilde{\\boldsymbol{\\beta}}})^2}.$$","code":""},{"path":"https://um-kevinhe.github.io/grplasso/articles/Models.html","id":"middle-layer-update-the-provider-effect-boldsymbolgamma","dir":"Articles","previous_headings":"Discrete Survival Logistic Model > Three-layer iterative update procedure","what":"middle layer: update the provider effect 𝛄\\boldsymbol{\\gamma}","title":"Models","text":"Given 𝛂̂\\hat{\\boldsymbol{\\alpha}} updated recently updated 𝛃̃\\tilde{\\boldsymbol{\\beta}}, consider Qλ,𝛄(𝛄)=−1n∑=1m∑j=1ni∑k=1kij{δij(tk)⋅(α̂k+γi+𝐙ij𝛃̃)−log(1+eα̂k+γi+𝐙ij𝛃̃)}Q_{\\lambda, \\boldsymbol{\\gamma}}(\\boldsymbol{\\gamma}) = - \\frac{1}{n} \\sum\\limits_{= 1}^m \\sum\\limits_{j=1}^{n_i} \\sum\\limits_{k=1}^{k_{ij}} \\{\\delta_{ij}\\left(t_{k}\\right) \\cdot (\\hat{\\alpha}_k + \\gamma_{} +  \\boldsymbol{Z}_{ij} \\tilde{\\boldsymbol{\\beta}}) -log(1 + e^{\\hat{\\alpha}_k + \\gamma_{} +  \\boldsymbol{Z}_{ij} \\tilde{\\boldsymbol{\\beta}}}) \\}. Use similar one-step Newton method γ̂=γ̃+Iλ−1(γ̃)Uλ(γ̃),\\hat{\\gamma}_i = \\tilde{\\gamma}_i + I_{\\lambda}^{-1}(\\tilde{\\gamma}_i) U_{\\lambda}(\\tilde{\\gamma}_i), γi\\gamma_{} represent recently updated value effect center ii, $$U_{\\lambda}(\\tilde{\\gamma}_i) = - \\frac{1}{n} \\sum_{j = 1}^{n_i} \\sum_{k = 1}^{k_{ij}} \\{\\delta_{ij} \\left(t_{k}\\right) - \\frac{e^{\\hat{\\alpha}_k + \\tilde{\\gamma}_i +  \\boldsymbol{Z}_{ij} \\tilde{\\boldsymbol{\\beta}}}}{1 + e^{\\hat{\\alpha}_k + \\tilde{\\gamma}_i +  \\boldsymbol{Z}_{ij} \\tilde{\\boldsymbol{\\beta}}}}\\} \\\\      I_{\\lambda}(\\tilde{\\gamma}_i) = - \\frac{1}{n}  \\sum_{j = 1}^{n_i} \\sum_{k = 1}^{k_{ij}} \\frac{e^{\\hat{\\alpha}_k + \\tilde{\\gamma}_i +  \\boldsymbol{Z}_{ij} \\tilde{\\boldsymbol{\\beta}}}}{(1 + e^{\\hat{\\alpha}_k + \\tilde{\\gamma}_i +  \\boldsymbol{Z}_{ij} \\tilde{\\boldsymbol{\\beta}}})^2}.$$ noted effect first provider set zero (reference group) prevent issues multicollinearity.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/articles/Models.html","id":"inner-layer-update-the-covariate-coefficient-boldsymbolbeta-1","dir":"Articles","previous_headings":"Discrete Survival Logistic Model > Three-layer iterative update procedure","what":"inner layer: update the covariate coefficient 𝛃\\boldsymbol{\\beta}","title":"Models","text":"Based 𝛂̂\\hat{\\boldsymbol{\\alpha}} 𝛄̂\\hat{\\boldsymbol{\\gamma}} updated previous two steps, define ℒβ(𝛃)=−1n∑=1m∑j=1ni∑k=1kij{δij(tk)⋅(α̂k+γ̂+𝐙ij𝛃)−log(1+eα̂k+γ̂+𝐙ij𝛃)}\\mathcal{L}_{\\beta}(\\boldsymbol{\\beta}) = - \\frac{1}{n} \\sum\\limits_{= 1}^m \\sum\\limits_{j=1}^{n_i} \\sum\\limits_{k=1}^{k_{ij}} \\{\\delta_{ij}\\left(t_{k}\\right) \\cdot (\\hat{\\alpha}_k + \\hat{\\gamma}_{} +  \\boldsymbol{Z}_{ij} \\boldsymbol{\\beta}) -log(1 + e^{\\hat{\\alpha}_k + \\hat{\\gamma}_{} +  \\boldsymbol{Z}_{ij} \\boldsymbol{\\beta}}) \\} consider Qλ,𝛃(𝛃)=1nℒβ(𝛃)+∑k=1pλk|βk|.Q_{\\lambda, \\boldsymbol{\\beta}}(\\boldsymbol{\\beta}) = \\frac{1}{n}  \\mathcal{L}_{\\beta}(\\boldsymbol{\\beta}) + \\sum_{k = 1}^p \\lambda_{k} |\\beta_k|. Denote Z(η̃ij)=η̃ij−{ℒη″(𝛈̃)−1ℒη′(𝛈̃)}ij=η̃ij+∑k=1kij[δij(tk)−eα̂k+η̃ij1+eα̂k+η̃ij]∑k=1kijeα̂k+η̃ij(1+eα̂k+η̃ij)2,Z(\\tilde{\\eta}_{ij}) = \\tilde{\\eta}_{ij} -  \\{\\mathcal{L}_{\\eta}''(\\tilde{\\boldsymbol{\\eta}})^{-1} \\mathcal{L}_{\\eta}'(\\tilde{\\boldsymbol{\\eta}})\\}_{ij} = \\tilde{\\eta}_{ij} + \\frac{\\sum\\limits_{k = 1}^{k_{ij}}[\\delta_{ij}(t_k) - \\frac{e^{\\hat{\\alpha}_k + \\tilde{\\eta}_{ij}}}{1 + e^{\\hat{\\alpha}_k + \\tilde{\\eta}_{ij}}}]}{\\sum\\limits_{k = 1}^{k_{ij}} \\frac{e^{\\hat{\\alpha}_k + \\tilde{\\eta}_{ij}}}{(1 + e^{\\hat{\\alpha}_k + \\tilde{\\eta}_{ij}})^2}}, ω̃ij=∑k=1kijeα̂k+η̃ij(1+eα̂k+η̃ij)2,\\tilde{\\omega}_{ij} = \\sum\\limits_{k = 1}^{k_{ij}} \\frac{e^{\\hat{\\alpha}_k + \\tilde{\\eta}_{ij}}}{(1 + e^{\\hat{\\alpha}_k + \\tilde{\\eta}_{ij}})^2}, coordinate-wise updating function given : βp=S{∑=1m∑j=1niw̃ijZijp(Z(η̃ij)−γ̂−𝐙ij𝛃̃(−p)),nλk}∑=1m∑j=1niw̃ijZijp2,\\beta_p = \\frac{S\\{\\sum\\limits_{= 1}^m \\sum\\limits_{j = 1}^{n_i} \\tilde{w}_{ij} {Z_{ijp}} (Z(\\tilde{\\eta}_{ij}) - \\hat{\\gamma}_i - \\boldsymbol{Z}_{ij} \\tilde{\\boldsymbol{\\beta}}_{(-p)}), n\\lambda_k\\}}{\\sum\\limits_{= 1}^m \\sum\\limits_{j = 1}^{n_i} \\tilde{w}_{ij} {Z_{ijp}}^2}, SS soft-thresholding operator defined . MM algorithm can also applied solving problem since ∑k=1kijeα̂k+ηij(1+eα̂k+ηij)2<14kij\\sum\\limits_{k = 1}^{k_{ij}} \\frac{e^{\\hat{\\alpha}_{k} + \\eta_{ij}}}{(1 + e^{\\hat{\\alpha}_{k} + \\eta_{ij}})^2} < \\frac{1}{4} k_{ij}. majorizing surrogate function constructed based 𝐖=(14k11⋱14km,nm)n×n,\\boldsymbol{W} = \\begin{pmatrix} \\frac{1}{4}k_{11} &  &  \\\\  & \\ddots &  \\\\ &  & \\frac{1}{4}k_{m,n_m} \\end{pmatrix}_{n \\times n}, corresponding updating function given βp=S{∑=1m∑j=1nikijZijp(Z(η̃ij)−γ̂−𝐙ij𝛃̃(−p)),4nλk}∑=1m∑j=1nikijZijp2.\\beta_p = \\frac{S\\{\\sum\\limits_{= 1}^m \\sum\\limits_{j = 1}^{n_i} k_{ij} {Z_{ijp}} (Z(\\tilde{\\eta}_{ij}) - \\hat{\\gamma}_i - \\boldsymbol{Z}_{ij} \\tilde{\\boldsymbol{\\beta}}_{(-p)}), 4n\\lambda_k\\}}{\\sum\\limits_{= 1}^m \\sum\\limits_{j = 1}^{n_i} k_{ij} {Z_{ijp}}^2}.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Yubo Shao. Author, maintainer.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Shao Y (2025). grplasso: Computationally Efficient Variable Selection Framework Data High-Dimensional clustered Effects. R package version 1.0, https://um-kevinhe.github.io/grplasso/, https://github.com/UM-KevinHe/grplasso.","code":"@Manual{,   title = {grplasso: Computationally Efficient Variable Selection Framework for Data with High-Dimensional clustered Effects},   author = {Yubo Shao},   year = {2025},   note = {R package version 1.0, https://um-kevinhe.github.io/grplasso/},   url = {https://github.com/UM-KevinHe/grplasso}, }"},{"path":"https://um-kevinhe.github.io/grplasso/index.html","id":"grplasso","dir":"","previous_headings":"","what":"Computationally Efficient Variable Selection Framework for Data with High-Dimensional clustered Effects","title":"Computationally Efficient Variable Selection Framework for Data with High-Dimensional clustered Effects","text":"contemporary era big data, volume health data generated healthcare providers, hospitals dialysis facilities, experienced remarkable upsurge. result, traditional statistical tools variable selection high-dimensional data encountered challenges maintaining computational efficiency. response issue, grplasso R package meticulously developed, offering powerful solution efficient variable selection multi-center data. Demonstrating superiority, statistical tool outperforms existing methods substantial margin, validated simulated studies real-world data.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Computationally Efficient Variable Selection Framework for Data with High-Dimensional clustered Effects","text":"Note: package still early stages development, please don’t hesitate report problems may experience. can install ‘grplasso’ via github: recommand start tutorial, provides overview package’s usage, including model training, selection penalization parameters, post-estimation procedures.","code":"require(\"devtools\") require(\"remotes\") remotes::install_github(\"UM-KevinHe/grplasso\", ref = \"main\")"},{"path":"https://um-kevinhe.github.io/grplasso/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting Help:","title":"Computationally Efficient Variable Selection Framework for Data with High-Dimensional clustered Effects","text":"encounter problems bugs, please contact us : ybshao@umich.edu, kevinhe@umich.edu.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/BinaryData.html","id":null,"dir":"Reference","previous_headings":"","what":"Example data for generalized linear models — BinaryData","title":"Example data for generalized linear models — BinaryData","text":"simulated data set containing response variable, provider information 5 covariates.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/BinaryData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example data for generalized linear models — BinaryData","text":"","code":"data(BinaryData)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/BinaryData.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example data for generalized linear models — BinaryData","text":"list containing following elements: data example data. Y response variable; Prov.ID center indicator (include 20 centers); Z1, ..., Z5 5 continuous covariates. Y.char variable name response variable. prov.char variable name provider indicator. Z.char variable names covariates. group vector describing covariates grouped.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/BinaryData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example data for generalized linear models — BinaryData","text":"","code":"data(BinaryData) data <- BinaryData$data head(data) #>   Y Prov.ID     Z1     Z2     Z3     Z4     Z5 #> 1 1      10 -0.006 -0.159  0.588  0.378 -1.430 #> 2 0      11  0.862 -0.162  0.243  0.503  0.549 #> 3 0      11  0.453  0.961  0.665  0.522  0.859 #> 4 1       8 -0.286  0.001  0.903  0.886 -0.324 #> 5 0      13  0.564 -0.194 -0.062 -0.792 -0.783 #> 6 1      18  0.676  1.095  2.223  1.367  1.060"},{"path":"https://um-kevinhe.github.io/grplasso/reference/coef.DiscSurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract coefficients of a DiscSurv object — coef.DiscSurv","title":"Extract coefficients of a DiscSurv object — coef.DiscSurv","text":"Return model coefficients DiscSurv object","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/coef.DiscSurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract coefficients of a DiscSurv object — coef.DiscSurv","text":"","code":"# S3 method for class 'DiscSurv' coef(fit, lambda, which = 1:length(fit$lambda), drop = TRUE, ...)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/coef.DiscSurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract coefficients of a DiscSurv object — coef.DiscSurv","text":"fit DiscSurv object. lambda values regularization parameter lambda coefficients requested. values lambda sequence fitted models, linear interpolation used. indices penalty parameter lambda predictions required. default, indices returned. lambda specified, override . drop whether keep coefficient names ...","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/coef.DiscSurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract coefficients of a DiscSurv object — coef.DiscSurv","text":"","code":"data(DiscTime) data <- DiscTime$data Event.char <- DiscTime$Event.char Z.char <- DiscTime$Z.char Time.char <- DiscTime$Time.char fit <- DiscSurv(data, Event.char, Z.char, Time.char) coef(fit, lambda = fit$lambda)$alpha[, 1:10] #>                 0.4261    0.3882    0.3537    0.3223    0.2937    0.2676 #> [Time: 0.53] -1.979501 -1.970055 -1.977003 -1.996580 -2.025985 -2.063312 #> [Time: 1.03] -2.110213 -2.069229 -2.043936 -2.030857 -2.027099 -2.024915 #> [Time: 3.92] -2.484907 -2.418504 -2.367851 -2.329504 -2.300521 -2.271900 #> [Time: 6.74] -2.355695 -2.272311 -2.204520 -2.148985 -2.102801 -2.057118 #> [Time: 12.5] -2.958691 -2.863140 -2.784495 -2.719193 -2.664049 -2.607962 #>                 0.2438    0.2221    0.2024    0.1844 #> [Time: 0.53] -2.108360 -2.159506 -2.215515 -2.275258 #> [Time: 1.03] -2.030033 -2.041091 -2.057155 -2.077143 #> [Time: 3.92] -2.250843 -2.236081 -2.226730 -2.221891 #> [Time: 6.74] -2.019057 -1.987374 -1.961171 -1.939712 #> [Time: 12.5] -2.560104 -2.519177 -2.484277 -2.454635 coef(fit, lambda = fit$lambda)$beta[, 1:10] #>    0.4261     0.3882     0.3537     0.3223       0.2937      0.2676     0.2438 #> Z1      0 -0.1556065 -0.2988513 -0.4321738 -0.555170528 -0.62756301 -0.6972625 #> Z2      0  0.0000000  0.0000000  0.0000000  0.000000000  0.00000000  0.0000000 #> Z3      0  0.0000000  0.0000000  0.0000000  0.000000000  0.00000000  0.0000000 #> Z4      0  0.0000000  0.0000000  0.0000000  0.000000000  0.00000000  0.0000000 #> Z5      0  0.0000000  0.0000000  0.0000000 -0.003092387 -0.06677843 -0.1269445 #>        0.2221     0.2024       0.1844 #> Z1 -0.7646826 -0.8306135 -0.891613065 #> Z2  0.0000000  0.0000000  0.000000000 #> Z3  0.0000000  0.0000000 -0.005933632 #> Z4  0.0000000  0.0000000  0.000000000 #> Z5 -0.1842370 -0.2383347 -0.287641261"},{"path":"https://um-kevinhe.github.io/grplasso/reference/coef.ppDiscSurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract coefficients of a ppDiscSurv object — coef.ppDiscSurv","title":"Extract coefficients of a ppDiscSurv object — coef.ppDiscSurv","text":"Return model coefficients ppDiscSurv object","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/coef.ppDiscSurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract coefficients of a ppDiscSurv object — coef.ppDiscSurv","text":"","code":"# S3 method for class 'ppDiscSurv' coef(fit, lambda, which = 1:length(fit$lambda), drop = TRUE, ...)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/coef.ppDiscSurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract coefficients of a ppDiscSurv object — coef.ppDiscSurv","text":"fit ppDiscSurv object. lambda values regularization parameter lambda coefficients requested. values lambda sequence fitted models, linear interpolation used. indices penalty parameter lambda predictions required. default, indices returned. lambda specified, override . drop whether keep coefficient names ...","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/coef.ppDiscSurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract coefficients of a ppDiscSurv object — coef.ppDiscSurv","text":"","code":"data(DiscTime) data <- DiscTime$data Event.char <- DiscTime$Event.char prov.char <- DiscTime$prov.char Z.char <- DiscTime$Z.char Time.char <- DiscTime$Time.char fit <- pp.DiscSurv(data, Event.char, prov.char, Z.char, Time.char) coef(fit, lambda = fit$lambda)$alpha[, 1:5] #>                 0.1601    0.1458    0.1329    0.1211    0.1103 #> [Time: 0.53] -1.668065 -1.747753 -1.824209 -1.898663 -1.971909 #> [Time: 1.03] -1.480994 -1.526815 -1.571328 -1.615488 -1.659886 #> [Time: 3.92] -1.622145 -1.641556 -1.661848 -1.683563 -1.706991 #> [Time: 6.74] -1.251585 -1.257340 -1.264124 -1.272503 -1.282795 #> [Time: 12.5] -1.781635 -1.780095 -1.780526 -1.783340 -1.788771 coef(fit, lambda = fit$lambda)$gamma[, 1:5] #>       0.1601     0.1458    0.1329     0.1211     0.1103 #> 1  0.0000000  0.0000000  0.000000  0.0000000  0.0000000 #> 2 -4.5665147 -4.3516946 -4.162992 -3.9945779 -3.8425705 #> 3 -0.7478311 -0.7116142 -0.682481 -0.6580980 -0.6367834 #> 4  1.2412090  1.1456446  1.059286  0.9815198  0.9121089 #> 5 -2.3399410 -2.1966372 -2.070536 -1.9577270 -1.8555876 coef(fit, lambda = fit$lambda)$beta[, 1:5] #>    0.1601     0.1458     0.1329     0.1211     0.1103 #> Z1      0 -0.1735757 -0.3325774 -0.4793679 -0.6155647 #> Z2      0  0.0000000  0.0000000  0.0000000  0.0000000 #> Z3      0  0.0000000  0.0000000  0.0000000  0.0000000 #> Z4      0  0.0000000  0.0000000  0.0000000  0.0000000 #> Z5      0  0.0000000  0.0000000  0.0000000  0.0000000"},{"path":"https://um-kevinhe.github.io/grplasso/reference/coef.ppLasso.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract coefficients of a ppLasso or gr_ppLasso object — coef.ppLasso","title":"Extract coefficients of a ppLasso or gr_ppLasso object — coef.ppLasso","text":"Return model coefficients ppLasso gr_ppLasso object","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/coef.ppLasso.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract coefficients of a ppLasso or gr_ppLasso object — coef.ppLasso","text":"","code":"# S3 method for class 'ppLasso' coef(fit, lambda, which = 1:length(fit$lambda), drop = TRUE, ...)  # S3 method for class 'gr_ppLasso' coef(fit, lambda, which = 1:length(fit$lambda), drop = TRUE, ...)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/coef.ppLasso.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract coefficients of a ppLasso or gr_ppLasso object — coef.ppLasso","text":"fit ppLasso gr_ppLasso object. lambda values regularization parameter lambda coefficients requested. values lambda sequence fitted models, linear interpolation used. indices penalty parameter lambda predictions required. default, indices returned. lambda specified, override . drop whether keep coefficient names ...","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/coef.ppLasso.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract coefficients of a ppLasso or gr_ppLasso object — coef.ppLasso","text":"","code":"#fit glm without grouped covariates data(BinaryData) data <- BinaryData$data Y.char <- BinaryData$Y.char prov.char <- BinaryData$prov.char Z.char <- BinaryData$Z.char fit <- pp.lasso(data, Y.char, Z.char, prov.char) coef(fit, lambda = fit$lambda)$beta[, 1:10] #>    0.132    0.1202    0.1096    0.0998     0.091    0.0829    0.0755    0.0688 #> Z1     0 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> Z2     0 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> Z3     0 0.1120347 0.2148847 0.3098777 0.3980465 0.4801436 0.5568409 0.6285796 #> Z4     0 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #> Z5     0 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #>       0.0627    0.0571 #> Z1 0.0000000 0.0000000 #> Z2 0.0000000 0.0000000 #> Z3 0.6957436 0.7586491 #> Z4 0.0000000 0.0000000 #> Z5 0.0000000 0.0000000 coef(fit, lambda = fit$lambda)$gamma[1:10, 1:5] #>         0.132     0.1202     0.1096     0.0998      0.091 #> 1  -0.2411977 -0.2939898 -0.3431091 -0.3889330 -0.4318211 #> 2  -1.9635362 -1.8742433 -1.7984115 -1.7336457 -1.6779754 #> 3  -1.2089403 -1.1883078 -1.1712888 -1.1572109 -1.1455229 #> 4  -1.9600386 -1.8922127 -1.8332183 -1.7815619 -1.7360041 #> 5  -0.5500569 -0.5698456 -0.5894538 -0.6087582 -0.6276779 #> 6  -1.3694159 -1.2813234 -1.2034985 -1.1342974 -1.0723356 #> 7  -0.4661063 -0.4936788 -0.5199327 -0.5449261 -0.5687380 #> 8  -0.4274344 -0.4203383 -0.4151684 -0.4115749 -0.4092523 #> 9   1.0329137  0.8945008  0.7694552  0.6557870  0.5517900 #> 10 -0.9075577 -0.9146380 -0.9232143 -0.9328743 -0.9433025 #fit glm with grouped covariates data(BinaryData) data <- BinaryData$data Y.char <- BinaryData$Y.char prov.char <- BinaryData$prov.char Z.char <- BinaryData$Z.char group <- BinaryData$group fit <- grp.lasso(data, Y.char, Z.char, prov.char, group = group) coef(fit, lambda = fit$lambda)$beta[, 1:5] #>    0.0939      0.0856       0.078        0.071      0.0647 #> Z1      0  0.00000000  0.00000000 -0.003334178 -0.05627111 #> Z2      0  0.00000000  0.00000000  0.003875496  0.06351446 #> Z3      0  0.11268128  0.21468084  0.307301593  0.38977908 #> Z4      0 -0.01162498 -0.01401619 -0.009610844 -0.00190843 #> Z5      0  0.00000000  0.00000000  0.000000000  0.00000000 coef(fit, lambda = fit$lambda)$gamma[1:10, 1:5] #>        0.0939     0.0856      0.078      0.071     0.0647 #> 1  -0.2411731 -0.2890605 -0.3366646 -0.3843345 -0.4426426 #> 2  -1.9635866 -1.8817822 -1.8080178 -1.7414115 -1.6832827 #> 3  -1.2089543 -1.1907172 -1.1742371 -1.1589555 -1.1394428 #> 4  -1.9600775 -1.8990257 -1.8418545 -1.7882081 -1.7355165 #> 5  -0.5500497 -0.5681728 -0.5871905 -0.6066594 -0.6253165 #> 6  -1.3694650 -1.2892476 -1.2136979 -1.1425348 -1.0753747 #> 7  -0.4660951 -0.4915285 -0.5170385 -0.5424109 -0.5680985 #> 8  -0.4274407 -0.4200726 -0.4148432 -0.4114738 -0.4111511 #> 9   1.0329839  0.9085190  0.7875110  0.6698040  0.5477673 #> 10 -0.9075578 -0.9153895 -0.9239389 -0.9332905 -0.9470281"},{"path":"https://um-kevinhe.github.io/grplasso/reference/coef.strat_cox.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract coefficients of a strat_cox object — coef.strat_cox","title":"Extract coefficients of a strat_cox object — coef.strat_cox","text":"Return model coefficients strat_cox object","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/coef.strat_cox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract coefficients of a strat_cox object — coef.strat_cox","text":"","code":"# S3 method for class 'strat_cox' coef(fit, lambda, which = 1:length(fit$lambda), drop = TRUE, ...)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/coef.strat_cox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract coefficients of a strat_cox object — coef.strat_cox","text":"fit strat_cox object. lambda values regularization parameter lambda coefficients requested. values lambda sequence fitted models, linear interpolation used. indices penalty parameter lambda predictions required. default, indices returned. lambda specified, override . drop whether keep coefficient names ...","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/coef.strat_cox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract coefficients of a strat_cox object — coef.strat_cox","text":"","code":"data(ContTime) data <- ContTime$data Event.char <- ContTime$Event.char prov.char <- ContTime$prov.char Z.char <- ContTime$Z.char Time.char <- ContTime$Time.char fit <- Strat.cox(data, Event.char, Z.char, Time.char, prov.char, group = c(1, 2, 2, 3, 3)) coef(fit, lambda = fit$lambda)[, 1:5] #>    0.0394      0.0368     0.0343       0.032      0.0298 #> Z1      0 -0.01983922 -0.0390155 -0.05686517 -0.07358008 #> Z2      0  0.00000000  0.0000000  0.00000000  0.00000000 #> Z3      0  0.00000000  0.0000000  0.00000000  0.00000000 #> Z4      0  0.00000000  0.0000000  0.00000000  0.00000000 #> Z5      0  0.00000000  0.0000000  0.00000000  0.00000000"},{"path":"https://um-kevinhe.github.io/grplasso/reference/ContTime.html","id":null,"dir":"Reference","previous_headings":"","what":"Example data for Cox models — ContTime","title":"Example data for Cox models — ContTime","text":"simulated data set containing observation time, event indicator, provider information 5 covariates.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/ContTime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example data for Cox models — ContTime","text":"","code":"data(ContTime)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/ContTime.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example data for Cox models — ContTime","text":"list containing following elements: data example data.time represents observation time; status event indicator; Prov.ID center indicator (include 5 centers); Z1, ..., Z5 5 continuous covariates. Event.char variable name event indicator. prov.char variable name provider indicator. Z.char variable names covariates. Time.char variable name observation time.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/ContTime.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example data for Cox models — ContTime","text":"","code":"data(ContTime) data <- ContTime$data head(data) #>      Prov.ID       Z1       Z2       Z3       Z4       Z5 status      time #> [1,]      11 3.431888 4.397010 3.800101 4.809899 4.049038      1 0.4984520 #> [2,]       4 2.789097 2.616714 3.401736 3.510431 3.650074      0 3.0000000 #> [3,]       9 5.451523 4.009896 5.473275 4.772835 4.708293      1 0.5987062 #> [4,]      15 2.421634 2.284766 1.747758 2.182607 1.072065      1 0.6406964 #> [5,]       9 5.827436 5.238138 5.536604 5.265083 4.735679      0 3.0000000 #> [6,]      18 2.140707 1.773304 1.792366 1.774502 3.209669      0 3.0000000"},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.DiscSurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validation for penalized discrete survival model (without provider information) — cv.DiscSurv","title":"Cross-validation for penalized discrete survival model (without provider information) — cv.DiscSurv","text":"Performs k-fold cross validation penalized discrete survival model (without provider information) grid values regularization parameter lambda.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.DiscSurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validation for penalized discrete survival model (without provider information) — cv.DiscSurv","text":"","code":"cv.DiscSurv(   data,   Event.char,   Z.char,   Time.char,   penalize.x = rep(1, length(Z.char)),   ...,   nfolds = 10,   seed,   fold,   trace.cv = FALSE )"},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.DiscSurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validation for penalized discrete survival model (without provider information) — cv.DiscSurv","text":"data dataframe list object contains variables model. Event.char name event indicator data character string. Event indicator binary variable 1 indicating event occurred 0 indicating (right) censoring. Z.char names covariates data vector character strings. Time.char name follow time data character string. penalize.x vector indicates whether corresponding covariate penalized, pp.DiscSurv function. ... extra arguments passed function. nfolds number cross-validation folds. Default 10. seed seed random number generator order obtain reproducible results. fold vector specifies fold observations belongs . default observations randomly assigned. trace.cv cv.DiscSurv provide user progress cross validation trace.cv = TRUE. Default FALSE.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.DiscSurv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validation for penalized discrete survival model (without provider information) — cv.DiscSurv","text":"object S3 class cv.DiscSurv. cve error value lambda, averaged across cross-validation folds. cvse estimated standard error associated value cve. lambda sequence regularization parameter values along cross-validation error calculated. fit fitted pp.DiscSurv object whole data. fold fold assignments cross-validation observation min index lambda corresponding lambda.min. lambda.min value lambda minimum cross-validation error.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.DiscSurv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-validation for penalized discrete survival model (without provider information) — cv.DiscSurv","text":"K. , J. Kalbfleisch, Y. Li, et al. (2013) Evaluating hospital readmission rates dialysis facilities; adjusting hospital effects. Lifetime Data Analysis, 19: 490-512.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.DiscSurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validation for penalized discrete survival model (without provider information) — cv.DiscSurv","text":"","code":"data(DiscTime) data <- DiscTime$data Event.char <- DiscTime$Event.char Z.char <- DiscTime$Z.char Time.char <- DiscTime$Time.char cv.fit <- cv.DiscSurv(data, Event.char, Z.char, Time.char, nfolds = 10, trace.cv = T) #> Starting CV fold #1... #> Starting CV fold #2... #> Starting CV fold #3... #> Starting CV fold #4... #> Starting CV fold #5... #> Starting CV fold #6... #> Starting CV fold #7... #> Starting CV fold #8... #> Starting CV fold #9... #> Starting CV fold #10... cv.fit$cve #>   [1] 0.6164357 0.5859204 0.5588632 0.5359219 0.5162308 0.4975886 0.4806902 #>   [8] 0.4659590 0.4531315 0.4418893 0.4319920 0.4232525 0.4155636 0.4088219 #>  [15] 0.4029151 0.3977430 0.3932264 0.3892878 0.3858700 0.3829060 0.3803241 #>  [22] 0.3780872 0.3761650 0.3745262 0.3731255 0.3719438 0.3709422 0.3701069 #>  [29] 0.3694028 0.3688292 0.3683501 0.3681269 0.3679872 0.3676270 0.3667747 #>  [36] 0.3654981 0.3644171 0.3634951 0.3626943 0.3620166 0.3614478 0.3609877 #>  [43] 0.3606192 0.3603222 0.3600887 0.3599045 0.3597558 0.3596067 0.3594923 #>  [50] 0.3594062 0.3593382 0.3592856 0.3592503 0.3592230 0.3592091 0.3591973 #>  [57] 0.3591958 0.3591976 0.3592005 0.3592063 0.3592159 0.3592223 0.3592350 #>  [64] 0.3592457 0.3592534 0.3592699 0.3592784 0.3592864 0.3592978 0.3593071 #>  [71] 0.3593180 0.3593254 0.3593340 0.3593394 0.3593485 0.3593559 0.3593590 #>  [78] 0.3593665 0.3593720 0.3593761 0.3593798 0.3593841 0.3593899 0.3593930 #>  [85] 0.3593968 0.3593992 0.3594039 0.3594053 0.3594077 0.3594074 0.3594102 #>  [92] 0.3594133 0.3594160 0.3594162 0.3594175 0.3594173 0.3594194 0.3594204 #>  [99] 0.3594209 0.3594217 cv.fit$lambda.min #> [1] 0.002327205"},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.grp.lasso.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validation for group penalized generalized regression model — cv.grp.lasso","title":"Cross-validation for group penalized generalized regression model — cv.grp.lasso","text":"Performs k-fold cross validation group penalized regression models grid values regularization parameter lambda.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.grp.lasso.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validation for group penalized generalized regression model — cv.grp.lasso","text":"","code":"cv.grp.lasso(   data,   Y.char,   Z.char,   prov.char,   group = 1:length(Z.char),   ...,   nfolds = 10,   seed,   fold,   trace.cv = FALSE )"},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.grp.lasso.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validation for group penalized generalized regression model — cv.grp.lasso","text":"data dataframe list object contains variables model. Y.char name response variable data character string, grp.lasso function. Z.char names covariates data vector character strings, grp.lasso function. prov.char name provider IDs variable data character string, grp.lasso function. group vector describing grouping coefficients. coefficients included model without penalized, assign group 0 (\"0\"). ... extra arguments passed function. nfolds number cross-validation folds. Default 10. seed seed random number generator order obtain reproducible results. fold vector specifies fold observations belongs . default observations randomly assigned. trace.cv cv.grp.lasso provide user progress cross validation trace.cv = TRUE. Default FALSE.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.grp.lasso.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validation for group penalized generalized regression model — cv.grp.lasso","text":"object S3 class cv.gr_ppLasso. cve error value lambda, averaged across cross-validation folds. cvse estimated standard error associated value cve. lambda sequence regularization parameter values along cross-validation error calculated. fit fitted gr_ppLasso object whole data. fold fold assignments cross-validation observation min index lambda corresponding lambda.min. lambda.min value lambda minimum cross-validation error.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.grp.lasso.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-validation for group penalized generalized regression model — cv.grp.lasso","text":"K. , J. Kalbfleisch, Y. Li, et al. (2013) Evaluating hospital readmission rates dialysis facilities; adjusting hospital effects. Lifetime Data Analysis, 19: 490-512.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.grp.lasso.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validation for group penalized generalized regression model — cv.grp.lasso","text":"","code":"data(BinaryData) data <- BinaryData$data Y.char <- BinaryData$Y.char prov.char <- BinaryData$prov.char Z.char <- BinaryData$Z.char group <- BinaryData$group cv.fit <- cv.grp.lasso(data, Y.char, Z.char, prov.char, group = group, nfolds = 10) # the best lambda using cross validation cv.fit$lambda.min #> [1] 0.001427324"},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.pp.DiscSurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validation for penalized discrete survival model (with provider information) — cv.pp.DiscSurv","title":"Cross-validation for penalized discrete survival model (with provider information) — cv.pp.DiscSurv","text":"Performs k-fold cross validation penalized discrete survival model (provider information) grid values regularization parameter lambda.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.pp.DiscSurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validation for penalized discrete survival model (with provider information) — cv.pp.DiscSurv","text":"","code":"cv.pp.DiscSurv(   data,   Event.char,   prov.char,   Z.char,   Time.char,   penalize.x = rep(1, length(Z.char)),   ...,   nfolds = 10,   seed,   fold,   trace.cv = FALSE )"},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.pp.DiscSurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validation for penalized discrete survival model (with provider information) — cv.pp.DiscSurv","text":"data dataframe list object contains variables model. Event.char name event indicator data character string. Event indicator binary variable 1 indicating event occurred 0 indicating (right) censoring. prov.char name provider IDs variable data character string. Z.char names covariates data vector character strings. Time.char name follow time data character string. penalize.x vector indicates whether corresponding covariate penalized, pp.DiscSurv function. ... extra arguments passed function. nfolds number cross-validation folds. Default 10. seed seed random number generator order obtain reproducible results. fold vector specifies fold observations belongs . default observations randomly assigned. trace.cv cv.pp.DiscSurv provide user progress cross validation trace.cv = TRUE. Default FALSE.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.pp.DiscSurv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validation for penalized discrete survival model (with provider information) — cv.pp.DiscSurv","text":"object S3 class cv.pp.DiscSurv. cve error value lambda, averaged across cross-validation folds. cvse estimated standard error associated value cve. lambda sequence regularization parameter values along cross-validation error calculated. fit fitted pp.DiscSurv object whole data. fold fold assignments cross-validation observation min index lambda corresponding lambda.min. lambda.min value lambda minimum cross-validation error.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.pp.DiscSurv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-validation for penalized discrete survival model (with provider information) — cv.pp.DiscSurv","text":"K. , J. Kalbfleisch, Y. Li, et al. (2013) Evaluating hospital readmission rates dialysis facilities; adjusting hospital effects. Lifetime Data Analysis, 19: 490-512.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.pp.DiscSurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validation for penalized discrete survival model (with provider information) — cv.pp.DiscSurv","text":"","code":"data(DiscTime) data <- DiscTime$data Event.char <- DiscTime$Event.char prov.char <- DiscTime$prov.char Z.char <- DiscTime$Z.char Time.char <- DiscTime$Time.char cv.fit <- cv.pp.DiscSurv(data, Event.char, prov.char, Z.char, Time.char, nfolds = 10, trace.cv = T) #> Starting CV fold #1... #> Starting CV fold #2... #> Starting CV fold #3... #> Starting CV fold #4... #> Starting CV fold #5... #> Starting CV fold #6... #> Starting CV fold #7... #> Starting CV fold #8... #> Starting CV fold #9... #> Starting CV fold #10... cv.fit$cve #>   [1] 0.5536994 0.4635804 0.4519723 0.4422659 0.4341065 0.4272753 0.4216070 #>   [8] 0.4158419 0.4098801 0.4040894 0.3991393 0.3949940 0.3915235 0.3885731 #>  [15] 0.3860438 0.3838311 0.3818779 0.3801677 0.3786650 0.3773935 0.3763252 #>  [22] 0.3754223 0.3742408 0.3726386 0.3710895 0.3698456 0.3688344 0.3680012 #>  [29] 0.3673003 0.3667266 0.3662740 0.3659188 0.3656171 0.3653780 0.3651955 #>  [36] 0.3650605 0.3649295 0.3648325 0.3647630 0.3647175 0.3646884 0.3646760 #>  [43] 0.3646711 0.3646772 0.3646887 0.3647062 0.3647269 0.3647486 0.3647732 #>  [50] 0.3647983 0.3648241 0.3648485 0.3648729 0.3648964 0.3649172 0.3649400 #>  [57] 0.3649605 0.3649794 0.3649982 0.3650151 0.3650319 0.3650461 0.3650609 #>  [64] 0.3650738 0.3650834 0.3650963 0.3651058 0.3651142 0.3651252 0.3651315 #>  [71] 0.3651395 0.3651457 0.3651525 0.3651572 0.3651631 0.3651667 0.3651729 #>  [78] 0.3651746 0.3651803 0.3651821 0.3651852 0.3651878 0.3651912 0.3651934 #>  [85] 0.3651958 0.3651986 0.3652000 0.3651998 0.3652017 0.3652036 0.3652050 #>  [92] 0.3652066 0.3652064 0.3652087 0.3652081 0.3652095 0.3652124 0.3652120 #>  [99] 0.3652116 0.3652125 cv.fit$lambda.min #> [1] 0.003215807"},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.pp.lasso.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validation for penalized generalized regression model — cv.pp.lasso","title":"Cross-validation for penalized generalized regression model — cv.pp.lasso","text":"Performs k-fold cross validation penalized regression models grid values regularization parameter lambda.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.pp.lasso.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validation for penalized generalized regression model — cv.pp.lasso","text":"","code":"cv.pp.lasso(   data,   Y.char,   Z.char,   prov.char,   penalize.x = rep(1, length(Z.char)),   ...,   nfolds = 10,   seed,   fold,   trace.cv = FALSE )"},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.pp.lasso.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validation for penalized generalized regression model — cv.pp.lasso","text":"data dataframe list object contains variables model. Y.char name response variable data character string, pp.lasso function. Z.char names covariates data vector character strings, pp.lasso function. prov.char name provider IDs variable data character string, pp.lasso function. penalize.x vector indicates whether corresponding covariate penalized, pp.lasso function. ... extra arguments passed function. nfolds number cross-validation folds. Default 10. seed seed random number generator order obtain reproducible results. fold vector specifies fold observations belongs . default observations randomly assigned. trace.cv cv.pp.lasso provide user progress cross validation trace.cv = TRUE. Default FALSE.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.pp.lasso.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validation for penalized generalized regression model — cv.pp.lasso","text":"object S3 class cv.ppLasso. cve error value lambda, averaged across cross-validation folds. cvse estimated standard error associated value cve. lambda sequence regularization parameter values along cross-validation error calculated. fit fitted pp.lasso object whole data. fold fold assignments cross-validation observation min index lambda corresponding lambda.min. lambda.min value lambda minimum cross-validation error.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.pp.lasso.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-validation for penalized generalized regression model — cv.pp.lasso","text":"K. , J. Kalbfleisch, Y. Li, et al. (2013) Evaluating hospital readmission rates dialysis facilities; adjusting hospital effects. Lifetime Data Analysis, 19: 490-512.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.pp.lasso.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validation for penalized generalized regression model — cv.pp.lasso","text":"","code":"data(BinaryData) data <- BinaryData$data Y.char <- BinaryData$Y.char prov.char <- BinaryData$prov.char Z.char <- BinaryData$Z.char cv.fit <- cv.pp.lasso(data, Y.char, Z.char, prov.char, nfolds = 10) # the best lambda using cross validation cv.fit$lambda.min #> [1] 0.001517182"},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.strat_cox.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validation for penalized stratified cox model — cv.strat_cox","title":"Cross-validation for penalized stratified cox model — cv.strat_cox","text":"Performs k-fold cross validation penalized stratified cox model grid values regularization parameter lambda.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.strat_cox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validation for penalized stratified cox model — cv.strat_cox","text":"","code":"cv.strat_cox(   data,   Event.char,   Z.char,   Time.char,   prov.char,   group = 1:length(Z.char),   se = c(\"quick\", \"bootstrap\"),   ...,   nfolds = 10,   seed,   fold,   trace.cv = FALSE )"},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.strat_cox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validation for penalized stratified cox model — cv.strat_cox","text":"data dataframe list object contains variables model. Event.char name event indicator data character string. Event indicator binary variable 1 indicating event occurred 0 indicating (right) censoring. Z.char names covariates data vector character strings. Time.char name follow time data character string. prov.char name provider IDs variable data character string. (can seen \"stratum\") group vector describing grouping coefficients. coefficients included model without penalized, assign group 0 (\"0\"). ... extra arguments passed function. nfolds number cross-validation folds. Default 10. seed seed random number generator order obtain reproducible results. fold vector specifies fold observations belongs . default observations randomly assigned. trace.cv cv.strat_cox provide user progress cross validation trace.cv = TRUE. Default FALSE.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.strat_cox.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-validation for penalized stratified cox model — cv.strat_cox","text":"object S3 class cv.strat_cox. cve error value lambda, averaged across cross-validation folds. cvse estimated standard error associated value cve. lambda sequence regularization parameter values along cross-validation error calculated. fit fitted strat_cox object whole data. fold fold assignments cross-validation observation min index lambda corresponding lambda.min. lambda.min value lambda minimum cross-validation error.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.strat_cox.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-validation for penalized stratified cox model — cv.strat_cox","text":"K. , J. Kalbfleisch, Y. Li, et al. (2013) Evaluating hospital readmission rates dialysis facilities; adjusting hospital effects. Lifetime Data Analysis, 19: 490-512.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/cv.strat_cox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validation for penalized stratified cox model — cv.strat_cox","text":"","code":"data(ContTime) data <- ContTime$data Event.char <- ContTime$Event.char prov.char <- ContTime$prov.char Z.char <- ContTime$Z.char Time.char <- ContTime$Time.char cv.fit <- cv.strat_cox(data, Event.char, Z.char, Time.char, prov.char, group = c(1, 2, 2, 3, 3), nfolds = 10, se = \"quick\") # the best lambda using cross validation cv.fit$lambda.min #> [1] 0.004862236"},{"path":"https://um-kevinhe.github.io/grplasso/reference/DiscSurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a penalized discrete survival model (without provider information) — DiscSurv","title":"Fit a penalized discrete survival model (without provider information) — DiscSurv","text":"Main function fitting penalized discrete survival model without provider information","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/DiscSurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a penalized discrete survival model (without provider information) — DiscSurv","text":"","code":"DiscSurv(   data,   Event.char,   Z.char,   Time.char,   standardize = T,   lambda,   nlambda = 100,   lambda.min.ratio = 1e-04,   penalize.x = rep(1, length(Z.char)),   penalized.multiplier,   nvar.max = p,   stop.dev.ratio = 0.001,   bound = 10,   backtrack = FALSE,   tol = 1e-04,   max.each.iter = 10000,   max.total.iter = (max.each.iter * nlambda),   actSet = TRUE,   actIter = max.each.iter,   actVarNum = sum(penalize.x == 1),   actSetRemove = F,   returnX = FALSE,   trace.lambda = FALSE,   threads = 1,   MM = FALSE,   return.transform.data = FALSE,   ... )"},{"path":"https://um-kevinhe.github.io/grplasso/reference/DiscSurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a penalized discrete survival model (without provider information) — DiscSurv","text":"data dataframe list object contains variables model. Event.char name event indicator data character string. Event indicator binary variable 1 indicating event occurred 0 indicating (right) censoring. Z.char names covariates data vector character strings. Time.char name follow time data character string. standardize logical flag x variable standardization, prior fitting model sequence. coefficients always returned original scale. Default standardize=TRUE. lambda user supplied lambda sequence. Typical usage program compute lambda sequence based nlambda lambda.min.ratio. nlambda number lambda values. Default 100. lambda.min.ratio fraction smallest value lambda lambda.max (smallest lambda coefficients zero) log scale. Default 1e-04. penalize.x vector indicates whether corresponding covariate penalized. equals 0, variable unpenalized, else penalized. Default vector 1's (covariates penalized). penalized.multiplier vector values representing multiplicative factors covariate's penalty multiplied. Default vector 1's. nvar.max number maximum selected variables. Default number covariates. bound positive number avoid inflation provider effect. Default 10. backtrack updating provider effect, whether use \"backtracking line search\" Newton method. tol convergence threshold. lambda, program stop maximum change covariate coefficient smaller tol. Default 1e-4. max..iter maximum number iterations lambda. Default 1e4. max.total.iter maximum number iterations entire path. Default max..iter * nlambda. actSet whether use active method variable selection. Default TRUE. actIter actSet = TRUE, maximum number iterations new updated active set. Default max..iter (.e. update current active set convergence ). actSetRemove actSet = TRUE, whether remove zero coefficients current active set. Default FALSE. returnX whether return standardized design matrix. Default FALSE. trace.lambda whether display progress fitting entire path. Default FALSE. threads number cores used parallel computing. MM whether use \"Majorize-Minimization\" algorithm optimize objective function. ... extra arguments passed function.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/DiscSurv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a penalized discrete survival model (without provider information) — DiscSurv","text":"object S3 class DiscSurv. beta fitted matrix covariate coefficients. number rows equal number coefficients, number columns equal nlambda. alpha fitted value logit-transformed baseline hazard. lambda sequence lambda values path. df estimates effective number selected variables points along regularization path. iter number iterations convergence value lambda.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/DiscSurv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a penalized discrete survival model (without provider information) — DiscSurv","text":"model fit Newton method coordinate descent method.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/DiscSurv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fit a penalized discrete survival model (without provider information) — DiscSurv","text":"K. , J. Kalbfleisch, Y. Li, et al. (2013) Evaluating hospital readmission rates dialysis facilities; adjusting hospital effects. Lifetime Data Analysis, 19: 490-512.","code":""},{"path":[]},{"path":"https://um-kevinhe.github.io/grplasso/reference/DiscSurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a penalized discrete survival model (without provider information) — DiscSurv","text":"","code":"data(DiscTime) data <- DiscTime$data Event.char <- DiscTime$Event.char Z.char <- DiscTime$Z.char Time.char <- DiscTime$Time.char fit <- DiscSurv(data, Event.char, Z.char, Time.char) # fit a discrete survival model without any given provider information. fit$beta[, 1:5] # covariate coefficient #>    0.4261     0.3882     0.3537     0.3223       0.2937 #> Z1      0 -0.1556065 -0.2988513 -0.4321738 -0.555182124 #> Z2      0  0.0000000  0.0000000  0.0000000  0.000000000 #> Z3      0  0.0000000  0.0000000  0.0000000  0.000000000 #> Z4      0  0.0000000  0.0000000  0.0000000  0.000000000 #> Z5      0  0.0000000  0.0000000  0.0000000 -0.003012663 fit$alpha[, 1:5] #time effect #>                 0.4261    0.3882    0.3537    0.3223    0.2937 #> [Time: 0.53] -1.979501 -1.970055 -1.977003 -1.996580 -2.025996 #> [Time: 1.03] -2.110213 -2.069229 -2.043936 -2.030857 -2.027110 #> [Time: 3.92] -2.484907 -2.418504 -2.367851 -2.329504 -2.300530 #> [Time: 6.74] -2.355695 -2.272311 -2.204520 -2.148985 -2.102809 #> [Time: 12.5] -2.958691 -2.863140 -2.784495 -2.719193 -2.664056"},{"path":"https://um-kevinhe.github.io/grplasso/reference/DiscTime.html","id":null,"dir":"Reference","previous_headings":"","what":"Example data for discrete survival models — DiscTime","title":"Example data for discrete survival models — DiscTime","text":"simulated data set containing observation time, event indicator, provider information 5 covariates.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/DiscTime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example data for discrete survival models — DiscTime","text":"","code":"data(DiscTime)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/DiscTime.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example data for discrete survival models — DiscTime","text":"list containing following elements: data example data.time represents observation time; status event indicator; Prov.ID center indicator (include 5 centers); Z1, ..., Z5 5 continuous covariates. Event.char variable name event indicator. prov.char variable name provider indicator. Z.char variable names covariates. Time.char variable name observation time.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/DiscTime.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example data for discrete survival models — DiscTime","text":"","code":"data(DiscTime) data <- DiscTime$data head(data) #>   Prov.ID     Z1     Z2     Z3     Z4     Z5  time status #> 1       4 -1.298 -1.471 -1.346 -1.775 -1.241  1.03      1 #> 2       5  0.192  0.163  0.953  1.083  0.371 12.50      0 #> 3       4 -2.315 -2.038 -1.629 -2.577 -2.008  0.53      1 #> 4       1 -0.198  1.231  0.633  0.739  0.214  6.74      1 #> 5       2  0.469  0.640 -0.583  0.161  0.927 12.50      0 #> 6       4 -1.445 -1.848 -3.024 -2.117 -1.894  0.53      1"},{"path":"https://um-kevinhe.github.io/grplasso/reference/grp.lasso.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a group penalized generalized regression model — grp.lasso","title":"Fit a group penalized generalized regression model — grp.lasso","text":"Main function fitting group penalized generalized regression model","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/grp.lasso.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a group penalized generalized regression model — grp.lasso","text":"","code":"grp.lasso(   data,   Y.char,   Z.char,   prov.char,   group = 1:length(Z.char),   group.multiplier,   standardize = T,   lambda,   nlambda = 100,   lambda.min.ratio = 1e-04,   lambda.early.stop = FALSE,   nvar.max = p,   group.max = length(unique(group)),   stop.dev.ratio = 0.001,   bound = 10,   backtrack = FALSE,   tol = 1e-04,   max.each.iter = 10000,   max.total.iter = (max.each.iter * nlambda),   actSet = TRUE,   actIter = max.each.iter,   actGroupNum = sum(unique(group) != 0),   actSetRemove = F,   returnX = FALSE,   trace.lambda = FALSE,   threads = 1,   ... )"},{"path":"https://um-kevinhe.github.io/grplasso/reference/grp.lasso.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a group penalized generalized regression model — grp.lasso","text":"data dataframe list object contains variables model. Y.char name response variable data character string. Z.char names covariates data vector character strings. prov.char name provider IDs variable data character string. \"prov.char\" specified, observations considered provider. group vector describing grouping coefficients. coefficients included model without penalized, assign group 0 (\"0\"). group.multiplier vector values representing multiplicative factors covariate's penalty multiplied. Default vector 1's. standardize logical flag x variable standardization, prior fitting model sequence. coefficients always returned original scale. Default standardize=TRUE. lambda user supplied lambda sequence. Typical usage program compute lambda sequence based nlambda lambda.min.ratio. nlambda number lambda values. Default 100. lambda.min.ratio fraction smallest value lambda lambda.max (smallest lambda coefficients zero) log scale. Default 1e-04. lambda.early.stop whether program stop running entire sequence lambda. Early stop based ratio deviance models two successive lambda. Default FALSE. nvar.max number maximum selected variables. Default number covariates. group.max number maximum selected groups. Default number groups. stop.dev.ratio lambda.early.stop = TRUE, ratio deviance early stopping. Default 1e-3. bound positive number avoid inflation provider effect. Default 10. backtrack updating provider effect, whether use \"backtracking line search\" Newton method. tol convergence threshold. lambda, program stop maximum change covariate coefficient smaller tol. Default 1e-4. max..iter maximum number iterations lambda. Default 1e4. max.total.iter maximum number iterations entire path. Default max..iter * nlambda. actSet whether use active method variable selection. Default TRUE. actIter actSet = TRUE, maximum number iterations new updated active set. Default max..iter (.e. update current active set convergence ). actGroupNum actSet = TRUE, maximum number variables can selected new active set time active set updated. Default number groups. actSetRemove actSet = TRUE, whether remove zero coefficients current active set. Default FALSE. returnX whether return standardized design matrix. Default FALSE. trace.lambda whether display progress fitting entire path. Default FALSE. threads number cores used parallel computing. ... extra arguments passed function.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/grp.lasso.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a group penalized generalized regression model — grp.lasso","text":"object S3 class gr_ppLasso. beta fitted matrix covariate coefficients. number rows equal number coefficients, number columns equal nlambda. gamma fitted value provider effects. group vector describing grouping coefficients. lambda sequence lambda values path. loss loss fitted model value lambda. linear.predictors linear predictors fitted model value lambda. df estimates effective number selected variables points along regularization path. iter number iterations convergence value lambda.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/grp.lasso.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a group penalized generalized regression model — grp.lasso","text":"model fit Newton method coordinate descent method.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/grp.lasso.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fit a group penalized generalized regression model — grp.lasso","text":"K. , J. Kalbfleisch, Y. Li, et al. (2013) Evaluating hospital readmission rates dialysis facilities; adjusting hospital effects. Lifetime Data Analysis, 19: 490-512.","code":""},{"path":[]},{"path":"https://um-kevinhe.github.io/grplasso/reference/grp.lasso.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a group penalized generalized regression model — grp.lasso","text":"","code":"data(BinaryData) data <- BinaryData$data Y.char <- BinaryData$Y.char prov.char <- BinaryData$prov.char Z.char <- BinaryData$Z.char group <- BinaryData$group fit <- grp.lasso(data, Y.char, Z.char, prov.char, group = group) # fitted values of covariate coefficients (under the lambda sequence that was automatically generated by the package). round(fit$beta[1:5, 1:5], 5) #>    0.0939   0.0856    0.078    0.071   0.0647 #> Z1      0  0.00000  0.00000 -0.00333 -0.05627 #> Z2      0  0.00000  0.00000  0.00388  0.06351 #> Z3      0  0.11268  0.21468  0.30730  0.38978 #> Z4      0 -0.01162 -0.01402 -0.00961 -0.00191 #> Z5      0  0.00000  0.00000  0.00000  0.00000 # estimated center effects round(fit$gamma[1:5, 1:5], 5) #>     0.0939   0.0856    0.078    0.071   0.0647 #> 1 -0.24117 -0.28906 -0.33666 -0.38433 -0.44264 #> 2 -1.96359 -1.88178 -1.80802 -1.74141 -1.68328 #> 3 -1.20895 -1.19072 -1.17424 -1.15896 -1.13944 #> 4 -1.96008 -1.89903 -1.84185 -1.78821 -1.73552 #> 5 -0.55005 -0.56817 -0.58719 -0.60666 -0.62532"},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.cv.DiscSurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the cross entropy loss from a cv.DiscSurv object — plot.cv.DiscSurv","title":"Plot the cross entropy loss from a cv.DiscSurv object — plot.cv.DiscSurv","text":"Return plot cross entropy loss cv.DiscSurv object","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.cv.DiscSurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the cross entropy loss from a cv.DiscSurv object — plot.cv.DiscSurv","text":"","code":"# S3 method for class 'cv.DiscSurv' plot(   fit,   log.x = T,   vertical.line = T,   col.vertical.line = \"blue\",   col.dot = \"red\" )"},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.cv.DiscSurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the cross entropy loss from a cv.DiscSurv object — plot.cv.DiscSurv","text":"fit cv.DiscSurv object. log.x whether horizontal axis log scale. vertical.line whether draws vertical line value cross-validaton error minimized.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.cv.DiscSurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the cross entropy loss from a cv.DiscSurv object — plot.cv.DiscSurv","text":"","code":"data(DiscTime) data <- DiscTime$data Event.char <- DiscTime$Event.char Z.char <- DiscTime$Z.char Time.char <- DiscTime$Time.char cv.fit.DiscSurv <- cv.DiscSurv(data, Event.char, Z.char, Time.char, nfolds = 10) plot(cv.fit.DiscSurv)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.cv.ppDiscSurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the cross entropy loss from a cv.ppDiscSurv object — plot.cv.ppDiscSurv","title":"Plot the cross entropy loss from a cv.ppDiscSurv object — plot.cv.ppDiscSurv","text":"Return plot cross entropy loss cv.ppDiscSurv object","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.cv.ppDiscSurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the cross entropy loss from a cv.ppDiscSurv object — plot.cv.ppDiscSurv","text":"","code":"# S3 method for class 'cv.ppDiscSurv' plot(   fit,   log.x = T,   vertical.line = T,   col.vertical.line = \"blue\",   col.dot = \"red\" )"},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.cv.ppDiscSurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the cross entropy loss from a cv.ppDiscSurv object — plot.cv.ppDiscSurv","text":"fit cv.ppDiscSurv object. log.x whether horizontal axis log scale. vertical.line whether draws vertical line value cross-validaton error minimized.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.cv.ppDiscSurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the cross entropy loss from a cv.ppDiscSurv object — plot.cv.ppDiscSurv","text":"","code":"data(DiscTime) data <- DiscTime$data Event.char <- DiscTime$Event.char prov.char <- DiscTime$prov.char Z.char <- DiscTime$Z.char Time.char <- DiscTime$Time.char cv.fit.ppDiscSurv <- cv.pp.DiscSurv(data, Event.char, prov.char, Z.char, Time.char, nfolds = 10) plot(cv.fit.ppDiscSurv)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.cv.ppLasso.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the cross entropy loss from a cv.ppLasso or cv.gr_ppLasso object — plot.cv.ppLasso","title":"Plot the cross entropy loss from a cv.ppLasso or cv.gr_ppLasso object — plot.cv.ppLasso","text":"Return plot cross entropy loss cv.ppLasso cv.gr_ppLasso object","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.cv.ppLasso.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the cross entropy loss from a cv.ppLasso or cv.gr_ppLasso object — plot.cv.ppLasso","text":"","code":"# S3 method for class 'cv.ppLasso' plot(   fit,   log.x = T,   vertical.line = T,   col.vertical.line = \"blue\",   col.dot = \"red\" )  # S3 method for class 'cv.gr_ppLasso' plot(   fit,   log.x = T,   vertical.line = T,   col.vertical.line = \"blue\",   col.dot = \"red\" )"},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.cv.ppLasso.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the cross entropy loss from a cv.ppLasso or cv.gr_ppLasso object — plot.cv.ppLasso","text":"fit cv.gr_ppLasso object. log.x whether horizontal axis log scale. vertical.line whether draws vertical line value cross-validaton error minimized.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.cv.ppLasso.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the cross entropy loss from a cv.ppLasso or cv.gr_ppLasso object — plot.cv.ppLasso","text":"","code":"data(BinaryData) data <- BinaryData$data Y.char <- BinaryData$Y.char prov.char <- BinaryData$prov.char Z.char <- BinaryData$Z.char cv.fit.pplasso <- cv.pp.lasso(data, Y.char, Z.char, prov.char, nfolds = 10) plot(cv.fit.pplasso)  data(BinaryData) data <- BinaryData$data Y.char <- BinaryData$Y.char prov.char <- BinaryData$prov.char Z.char <- BinaryData$Z.char group <- BinaryData$group cv.fit.grplasso <- cv.grp.lasso(data, Y.char, Z.char, prov.char, group = group, nfolds = 10) plot(cv.fit.grplasso)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.cv.strat_cox.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the cross entropy loss from a cv.strat_cox object — plot.cv.strat_cox","title":"Plot the cross entropy loss from a cv.strat_cox object — plot.cv.strat_cox","text":"Return plot cross entropy loss cv.strat_cox object","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.cv.strat_cox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the cross entropy loss from a cv.strat_cox object — plot.cv.strat_cox","text":"","code":"# S3 method for class 'cv.strat_cox' plot(   fit,   log.x = T,   vertical.line = T,   col.vertical.line = \"blue\",   col.dot = \"red\" )"},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.cv.strat_cox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the cross entropy loss from a cv.strat_cox object — plot.cv.strat_cox","text":"fit cv.strat_cox object. log.x whether horizontal axis log scale. vertical.line whether draws vertical line value cross-validaton error minimized.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.cv.strat_cox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the cross entropy loss from a cv.strat_cox object — plot.cv.strat_cox","text":"","code":"data(ContTime) data <- ContTime$data Event.char <- ContTime$Event.char prov.char <- ContTime$prov.char Z.char <- ContTime$Z.char Time.char <- ContTime$Time.char cv.fit.strat_cox <- cv.strat_cox(data, Event.char, Z.char, Time.char, prov.char, group = c(1, 2, 2, 3, 3), nfolds = 10) plot(cv.fit.strat_cox)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.DiscSurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot regularization path of coefficients from a DiscSurv object — plot.DiscSurv","title":"Plot regularization path of coefficients from a DiscSurv object — plot.DiscSurv","text":"Return plot regularization path DiscSurv object","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.DiscSurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot regularization path of coefficients from a DiscSurv object — plot.DiscSurv","text":"","code":"# S3 method for class 'DiscSurv' plot(fit, log.x = T, label = F)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.DiscSurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot regularization path of coefficients from a DiscSurv object — plot.DiscSurv","text":"fit DiscSurv object. log.x whether horizontal axis log scale. label whether annotates plot labels.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.DiscSurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot regularization path of coefficients from a DiscSurv object — plot.DiscSurv","text":"","code":"data(DiscTime) data <- DiscTime$data Event.char <- DiscTime$Event.char Z.char <- DiscTime$Z.char Time.char <- DiscTime$Time.char fit <- DiscSurv(data, Event.char, Z.char, Time.char) plot(fit, label = T)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.ppDiscSurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot regularization path of coefficients from a ppDiscSurv object — plot.ppDiscSurv","title":"Plot regularization path of coefficients from a ppDiscSurv object — plot.ppDiscSurv","text":"Return plot regularization path ppDiscSurv object","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.ppDiscSurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot regularization path of coefficients from a ppDiscSurv object — plot.ppDiscSurv","text":"","code":"# S3 method for class 'ppDiscSurv' plot(fit, log.x = T, label = F)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.ppDiscSurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot regularization path of coefficients from a ppDiscSurv object — plot.ppDiscSurv","text":"fit ppDiscSurv object. log.x whether horizontal axis log scale. label whether annotates plot labels.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.ppDiscSurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot regularization path of coefficients from a ppDiscSurv object — plot.ppDiscSurv","text":"","code":"data(DiscTime) data <- DiscTime$data Event.char <- DiscTime$Event.char prov.char <- DiscTime$prov.char Z.char <- DiscTime$Z.char Time.char <- DiscTime$Time.char fit <- pp.DiscSurv(data, Event.char, prov.char, Z.char, Time.char) plot(fit, label = T)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.ppLasso.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot regularization path of coefficients from a ppLasso or gr_ppLasso object — plot.ppLasso","title":"Plot regularization path of coefficients from a ppLasso or gr_ppLasso object — plot.ppLasso","text":"Return plot regularization path ppLasso gr_ppLasso object","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.ppLasso.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot regularization path of coefficients from a ppLasso or gr_ppLasso object — plot.ppLasso","text":"","code":"# S3 method for class 'ppLasso' plot(fit, log.x = T, label = F)  # S3 method for class 'gr_ppLasso' plot(fit, log.x = T, label = F)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.ppLasso.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot regularization path of coefficients from a ppLasso or gr_ppLasso object — plot.ppLasso","text":"fit gr_ppLasso object. log.x whether horizontal axis log scale. label whether annotates plot labels.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.ppLasso.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot regularization path of coefficients from a ppLasso or gr_ppLasso object — plot.ppLasso","text":"","code":"data(BinaryData) data <- BinaryData$data Y.char <- BinaryData$Y.char prov.char <- BinaryData$prov.char Z.char <- BinaryData$Z.char fit <- pp.lasso(data, Y.char, Z.char, prov.char) plot(fit, label = T)  data(BinaryData) data <- BinaryData$data Y.char <- BinaryData$Y.char prov.char <- BinaryData$prov.char Z.char <- BinaryData$Z.char group <- BinaryData$group fit <- grp.lasso(data, Y.char, Z.char, prov.char, group = group) plot(fit, label = T)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.strat_cox.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot regularization path of coefficients from a strat_cox object — plot.strat_cox","title":"Plot regularization path of coefficients from a strat_cox object — plot.strat_cox","text":"Return plot regularization path strat_cox object","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.strat_cox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot regularization path of coefficients from a strat_cox object — plot.strat_cox","text":"","code":"# S3 method for class 'strat_cox' plot(fit, log.x = T, label = F)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.strat_cox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot regularization path of coefficients from a strat_cox object — plot.strat_cox","text":"fit strat_cox object. log.x whether horizontal axis log scale. label whether annotates plot labels.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/plot.strat_cox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot regularization path of coefficients from a strat_cox object — plot.strat_cox","text":"","code":"data(ContTime) data <- ContTime$data Event.char <- ContTime$Event.char prov.char <- ContTime$prov.char Z.char <- ContTime$Z.char Time.char <- ContTime$Time.char fit <- Strat.cox(data, Event.char, Z.char, Time.char, prov.char, group = c(1, 2, 2, 3, 3)) plot(fit, label = T)"},{"path":"https://um-kevinhe.github.io/grplasso/reference/pp.DiscSurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a penalized discrete survival model — pp.DiscSurv","title":"Fit a penalized discrete survival model — pp.DiscSurv","text":"Main function fitting penalized discrete survival model","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/pp.DiscSurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a penalized discrete survival model — pp.DiscSurv","text":"","code":"pp.DiscSurv(   data,   Event.char,   prov.char,   Z.char,   Time.char,   lambda,   nlambda = 100,   lambda.min.ratio = 1e-04,   penalize.x = rep(1, length(Z.char)),   penalized.multiplier,   lambda.early.stop = FALSE,   nvar.max = p,   stop.dev.ratio = 0.001,   bound = 10,   backtrack = FALSE,   tol = 1e-04,   max.each.iter = 10000,   max.total.iter = (max.each.iter * nlambda),   actSet = TRUE,   actIter = max.each.iter,   actVarNum = sum(penalize.x == 1),   actSetRemove = F,   returnX = FALSE,   trace.lambda = FALSE,   threads = 1,   MM = FALSE,   return.transform.data = FALSE,   ... )"},{"path":"https://um-kevinhe.github.io/grplasso/reference/pp.DiscSurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a penalized discrete survival model — pp.DiscSurv","text":"data dataframe list object contains variables model. Event.char name event indicator data character string. Event indicator binary variable 1 indicating event occurred 0 indicating (right) censoring. prov.char name provider IDs variable data character string. Z.char names covariates data vector character strings. Time.char name follow time data character string. lambda user supplied lambda sequence. Typical usage program compute lambda sequence based nlambda lambda.min.ratio. nlambda number lambda values. Default 100. lambda.min.ratio fraction smallest value lambda lambda.max (smallest lambda coefficients zero) log scale. Default 1e-04. penalize.x vector indicates whether corresponding covariate penalized. equals 0, variable unpenalized, else penalized. Default vector 1's (covariates penalized). penalized.multiplier vector values representing multiplicative factors covariate's penalty multiplied. Default vector 1's. lambda.early.stop whether program stop running entire sequence lambda. Early stop based ratio deviance models two successive lambda. Default FALSE. nvar.max number maximum selected variables. Default number covariates. stop.dev.ratio lambda.early.stop = TRUE, ratio deviance early stopping. Default 1e-3. bound positive number avoid inflation provider effect. Default 10. backtrack updating provider effect, whether use \"backtracking line search\" Newton method. tol convergence threshold. lambda, program stop maximum change covariate coefficient smaller tol. Default 1e-4. max..iter maximum number iterations lambda. Default 1e4. max.total.iter maximum number iterations entire path. Default max..iter * nlambda. actSet whether use active method variable selection. Default TRUE. actIter actSet = TRUE, maximum number iterations new updated active set. Default max..iter (.e. update current active set convergence ). actSetRemove actSet = TRUE, whether remove zero coefficients current active set. Default FALSE. returnX whether return standardized design matrix. Default FALSE. trace.lambda whether display progress fitting entire path. Default FALSE. threads number cores used parallel computing. MM whether use \"Majorize-Minimization\" algorithm optimize objective function. ... extra arguments passed function.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/pp.DiscSurv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a penalized discrete survival model — pp.DiscSurv","text":"object S3 class ppDiscSurv. beta fitted matrix covariate coefficients. number rows equal number coefficients, number columns equal nlambda. alpha fitted value logit-transformed baseline hazard. gamma fitted value provider effects. effect first provider set reference group. lambda sequence lambda values path. df estimates effective number selected variables points along regularization path. iter number iterations convergence value lambda.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/pp.DiscSurv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a penalized discrete survival model — pp.DiscSurv","text":"model fit Newton method coordinate descent method.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/pp.DiscSurv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fit a penalized discrete survival model — pp.DiscSurv","text":"K. , J. Kalbfleisch, Y. Li, et al. (2013) Evaluating hospital readmission rates dialysis facilities; adjusting hospital effects. Lifetime Data Analysis, 19: 490-512.","code":""},{"path":[]},{"path":"https://um-kevinhe.github.io/grplasso/reference/pp.DiscSurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a penalized discrete survival model — pp.DiscSurv","text":"","code":"data(DiscTime) data <- DiscTime$data Event.char <- DiscTime$Event.char prov.char <- DiscTime$prov.char Z.char <- DiscTime$Z.char Time.char <- DiscTime$Time.char fit <- pp.DiscSurv(data, Event.char, prov.char, Z.char, Time.char) fit$beta[, 1:5] #>    0.1601     0.1458     0.1329     0.1211     0.1103 #> Z1      0 -0.1735757 -0.3325774 -0.4793679 -0.6155647 #> Z2      0  0.0000000  0.0000000  0.0000000  0.0000000 #> Z3      0  0.0000000  0.0000000  0.0000000  0.0000000 #> Z4      0  0.0000000  0.0000000  0.0000000  0.0000000 #> Z5      0  0.0000000  0.0000000  0.0000000  0.0000000 fit$alpha[, 1:5] #>                 0.1601    0.1458    0.1329    0.1211    0.1103 #> [Time: 0.53] -1.668065 -1.747753 -1.824209 -1.898663 -1.971909 #> [Time: 1.03] -1.480994 -1.526815 -1.571328 -1.615488 -1.659886 #> [Time: 3.92] -1.622145 -1.641556 -1.661848 -1.683563 -1.706991 #> [Time: 6.74] -1.251585 -1.257340 -1.264124 -1.272503 -1.282795 #> [Time: 12.5] -1.781635 -1.780095 -1.780526 -1.783340 -1.788771 fit$gamma[, 1:5] #effect of the first provider is set to be zero #>       0.1601     0.1458    0.1329     0.1211     0.1103 #> 1  0.0000000  0.0000000  0.000000  0.0000000  0.0000000 #> 2 -4.5665147 -4.3516946 -4.162992 -3.9945779 -3.8425705 #> 3 -0.7478311 -0.7116142 -0.682481 -0.6580980 -0.6367834 #> 4  1.2412090  1.1456446  1.059286  0.9815198  0.9121089 #> 5 -2.3399410 -2.1966372 -2.070536 -1.9577270 -1.8555876"},{"path":"https://um-kevinhe.github.io/grplasso/reference/pp.lasso.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a penalized generalized regression model — pp.lasso","title":"Fit a penalized generalized regression model — pp.lasso","text":"Main function fitting penalized generalized regression","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/pp.lasso.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a penalized generalized regression model — pp.lasso","text":"","code":"pp.lasso(   data,   Y.char,   Z.char,   prov.char,   standardize = T,   lambda,   nlambda = 100,   lambda.min.ratio = 1e-04,   penalize.x = rep(1, length(Z.char)),   penalized.multiplier,   lambda.early.stop = FALSE,   nvar.max = p,   stop.dev.ratio = 0.001,   bound = 10,   backtrack = FALSE,   tol = 1e-04,   max.each.iter = 10000,   max.total.iter = (max.each.iter * nlambda),   actSet = TRUE,   actIter = max.each.iter,   actVarNum = sum(penalize.x == 1),   actSetRemove = F,   returnX = FALSE,   trace.lambda = FALSE,   threads = 1,   MM = FALSE,   ... )"},{"path":"https://um-kevinhe.github.io/grplasso/reference/pp.lasso.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a penalized generalized regression model — pp.lasso","text":"data dataframe list object contains variables model. Y.char name response variable data character string. Z.char names covariates data vector character strings. prov.char name provider IDs variable data character string. \"prov.char\" specified, observations considered provider. standardize logical flag x variable standardization, prior fitting model sequence. coefficients always returned original scale. Default standardize=TRUE. lambda user supplied lambda sequence. Typical usage program compute lambda sequence based nlambda lambda.min.ratio. nlambda number lambda values. Default 100. lambda.min.ratio fraction smallest value lambda lambda.max (smallest lambda coefficients zero) log scale. Default 1e-04. penalize.x vector indicates whether corresponding covariate penalized. equals 0, variable unpenalized, else penalized. Default vector 1's (covariates penalized). penalized.multiplier vector values representing multiplicative factors covariate's penalty multiplied. Default vector 1's. lambda.early.stop whether program stop running entire sequence lambda. Early stop based ratio deviance models two successive lambda. Default FALSE. nvar.max number maximum selected variables. Default number covariates. stop.dev.ratio lambda.early.stop = TRUE, ratio deviance early stopping. Default 1e-3. bound positive number avoid inflation provider effect. Default 10. backtrack updating provider effect, whether use \"backtracking line search\" Newton method. tol convergence threshold. lambda, program stop maximum change covariate coefficient smaller tol. Default 1e-4. max..iter maximum number iterations lambda. Default 1e4. max.total.iter maximum number iterations entire path. Default max..iter * nlambda. actSet whether use active method variable selection. Default TRUE. actIter actSet = TRUE, maximum number iterations new updated active set. Default max..iter (.e. update current active set convergence ). actVarNum actSet = TRUE, maximum number variables can selected new active set time active set updated. Default nvar.max. actSetRemove actSet = TRUE, whether remove zero coefficients current active set. Default FALSE. returnX whether return standardized design matrix. Default FALSE. trace.lambda whether display progress fitting entire path. Default FALSE. threads number cores used parallel computing. MM whether use \"Majorize-Minimization\" algorithm optimize objective function. ... extra arguments passed function.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/pp.lasso.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a penalized generalized regression model — pp.lasso","text":"object S3 class ppLasso. beta fitted matrix covariate coefficients. number rows equal number coefficients, number columns equal nlambda. gamma fitted value provider effects. lambda sequence lambda values path. loss loss fitted model value lambda. linear.predictors linear predictors fitted model value lambda. df estimates effective number selected variables points along regularization path. iter number iterations convergence value lambda.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/pp.lasso.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a penalized generalized regression model — pp.lasso","text":"model fit Newton method coordinate descent method.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/pp.lasso.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fit a penalized generalized regression model — pp.lasso","text":"K. , J. Kalbfleisch, Y. Li, et al. (2013) Evaluating hospital readmission rates dialysis facilities; adjusting hospital effects. Lifetime Data Analysis, 19: 490-512.","code":""},{"path":[]},{"path":"https://um-kevinhe.github.io/grplasso/reference/pp.lasso.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a penalized generalized regression model — pp.lasso","text":"","code":"data(BinaryData) data <- BinaryData$data Y.char <- BinaryData$Y.char prov.char <- BinaryData$prov.char Z.char <- BinaryData$Z.char fit <- pp.lasso(data, Y.char, Z.char, prov.char) # fitted values of covariate coefficients (under the lambda sequence that was automatically generated by the package). round(fit$beta[1:5, 1:5], 5) #>    0.132  0.1202  0.1096  0.0998   0.091 #> Z1     0 0.00000 0.00000 0.00000 0.00000 #> Z2     0 0.00000 0.00000 0.00000 0.00000 #> Z3     0 0.11203 0.21488 0.30988 0.39805 #> Z4     0 0.00000 0.00000 0.00000 0.00000 #> Z5     0 0.00000 0.00000 0.00000 0.00000 # estimated center effects round(fit$gamma[1:5, 1:5], 5) #>      0.132   0.1202   0.1096   0.0998    0.091 #> 1 -0.24120 -0.29399 -0.34311 -0.38893 -0.43182 #> 2 -1.96354 -1.87424 -1.79841 -1.73365 -1.67798 #> 3 -1.20894 -1.18831 -1.17129 -1.15721 -1.14552 #> 4 -1.96004 -1.89221 -1.83322 -1.78156 -1.73600 #> 5 -0.55006 -0.56985 -0.58945 -0.60876 -0.62768"},{"path":"https://um-kevinhe.github.io/grplasso/reference/predict.DiscSurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Predictions of a DiscSurv object — predict.DiscSurv","title":"Predictions of a DiscSurv object — predict.DiscSurv","text":"Return model predictions DiscSurv object","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/predict.DiscSurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predictions of a DiscSurv object — predict.DiscSurv","text":"","code":"# S3 method for class 'DiscSurv' predict(   fit,   data,   Event.char,   Z.char,   Time.char,   lambda,   which = 1:length(fit$lambda),   type = c(\"response\", \"vars\", \"nvars\"),   return.Array = TRUE,   which.lambda = \"all\",   ... )"},{"path":"https://um-kevinhe.github.io/grplasso/reference/predict.DiscSurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predictions of a DiscSurv object — predict.DiscSurv","text":"fit DiscSurv object. data dataframe list object contains variables prediction. Event.char name event indicator data character string. Z.char names covariates data vector character strings. Time.char name observation time data character string. lambda values regularization parameter lambda predictions requested. values lambda sequence fitted models, linear interpolation used. indices penalty parameter lambda predictions required. default, indices returned. lambda specified, override . type type prediction: response: fitted values (.e., exp(eta)/(1 + exp(eta))) vars: indices non-zero coefficients nvars: number non-zero coefficients .lambda determine lambda values included output prediction. default, value set \",\" resulting matrix predicted values lambda presented list. However, specific numeric values provided, predicted matrix corresponding specified values included output. ...","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/predict.DiscSurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predictions of a DiscSurv object — predict.DiscSurv","text":"","code":"data(DiscTime) data <- DiscTime$data Event.char <- DiscTime$Event.char Z.char <- DiscTime$Z.char Time.char <- DiscTime$Time.char fit <- DiscSurv(data, Event.char, Z.char, Time.char) predict(fit, data, Event.char, Z.char, Time.char, lambda = fit$lambda, type = \"response\", which.lambda = fit$lambda[1])[1:5,] #>   Individual [Time: 0.53] [Time: 1.03] [Time: 3.92] [Time: 6.74] [Time: 12.5] #> 1          1     0.121372    0.1081081           NA           NA           NA #> 2          2     0.121372    0.1081081   0.07692308   0.08661417   0.04932735 #> 3          3     0.121372           NA           NA           NA           NA #> 4          4     0.121372    0.1081081   0.07692308   0.08661417           NA #> 5          5     0.121372    0.1081081   0.07692308   0.08661417   0.04932735 predict(fit, data, Event.char, Z.char, Time.char, lambda = 0.01, type = \"vars\") #> Z1 Z2 Z3 Z4 Z5  #>  1  2  3  4  5"},{"path":"https://um-kevinhe.github.io/grplasso/reference/predict.ppDiscSurv.html","id":null,"dir":"Reference","previous_headings":"","what":"Predictions of a ppDiscSurv object — predict.ppDiscSurv","title":"Predictions of a ppDiscSurv object — predict.ppDiscSurv","text":"Return model predictions ppDiscSurv object","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/predict.ppDiscSurv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predictions of a ppDiscSurv object — predict.ppDiscSurv","text":"","code":"# S3 method for class 'ppDiscSurv' predict(   fit,   data,   Event.char,   prov.char,   Z.char,   Time.char,   lambda,   which = 1:length(fit$lambda),   type = c(\"response\", \"vars\", \"nvars\"),   return.Array = TRUE,   which.lambda = \"all\",   ... )"},{"path":"https://um-kevinhe.github.io/grplasso/reference/predict.ppDiscSurv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predictions of a ppDiscSurv object — predict.ppDiscSurv","text":"fit ppDiscSurv object. data dataframe list object contains variables prediction. Event.char name event indicator data character string. prov.char name provider IDs variable data character string. Z.char names covariates data vector character strings. Time.char name observation time data character string. lambda values regularization parameter lambda predictions requested. values lambda sequence fitted models, linear interpolation used. indices penalty parameter lambda predictions required. default, indices returned. lambda specified, override . type type prediction: response: fitted values (.e., exp(eta)/(1 + exp(eta))) vars: indices non-zero coefficients nvars: number non-zero coefficients .lambda determine lambda values included output prediction. default, value set \",\" resulting matrix predicted values lambda presented list. However, specific numeric values provided, predicted matrix corresponding specified values included output. ...","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/predict.ppDiscSurv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predictions of a ppDiscSurv object — predict.ppDiscSurv","text":"","code":"data(DiscTime) data <- DiscTime$data Event.char <- DiscTime$Event.char prov.char <- DiscTime$prov.char Z.char <- DiscTime$Z.char Time.char <- DiscTime$Time.char fit <- pp.DiscSurv(data, Event.char, prov.char, Z.char, Time.char) predict(fit, data, Event.char, prov.char, Z.char, Time.char, lambda = fit$lambda, type = \"response\", which.lambda = fit$lambda[1])[1:5,] #>   Individual [Time: 0.53] [Time: 1.03] [Time: 3.92] [Time: 6.74] [Time: 12.5] #> 1          1    0.1586823    0.1852773           NA           NA           NA #> 2          2    0.1586823    0.1852773    0.1649092    0.2224258    0.1441013 #> 3          3    0.1586823           NA           NA           NA           NA #> 4          4    0.1586823    0.1852773    0.1649092    0.2224258           NA #> 5          5    0.1586823    0.1852773    0.1649092    0.2224258    0.1441013 predict(fit, data, Event.char, prov.char, Z.char, Time.char, lambda = 0.04, type = \"vars\") #> Z1 Z3 Z5  #>  1  3  5"},{"path":"https://um-kevinhe.github.io/grplasso/reference/predict.ppLasso.html","id":null,"dir":"Reference","previous_headings":"","what":"Predictions of a ppLasso or gr_ppLasso object — predict.ppLasso","title":"Predictions of a ppLasso or gr_ppLasso object — predict.ppLasso","text":"Return model predictions ppLasso gr_ppLasso object","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/predict.ppLasso.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predictions of a ppLasso or gr_ppLasso object — predict.ppLasso","text":"","code":"# S3 method for class 'ppLasso' predict(   fit,   data,   Z.char,   prov.char,   lambda,   which = 1:length(fit$lambda),   type = c(\"link\", \"response\", \"class\", \"vars\", \"nvars\"),   ... )  # S3 method for class 'gr_ppLasso' predict(   fit,   data,   Z.char,   prov.char,   lambda,   which = 1:length(fit$lambda),   type = c(\"link\", \"response\", \"class\", \"vars\", \"groups\", \"nvars\", \"ngroups\",     \"beta.norm\"),   ... )"},{"path":"https://um-kevinhe.github.io/grplasso/reference/predict.ppLasso.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predictions of a ppLasso or gr_ppLasso object — predict.ppLasso","text":"fit ppLasso gr_ppLasso. data dataframe list object contains variables prediction. Z.char names covariates data vector character strings. prov.char name provider IDs variable data character string. lambda values regularization parameter lambda predictions requested. values lambda sequence fitted models, linear interpolation used. indices penalty parameter lambda predictions required. default, indices returned. lambda specified, override . type type prediction: link: linear predictors response: fitted values (.e., exp(link)/(1 + exp(link))) class: binomial outcome largest probability vars: indices non-zero coefficients nvars: number non-zero coefficients groups: indices non-zero groups ngroups: number non-zero coefficients beta.norm: L2 norm coefficients group ...","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/predict.ppLasso.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predictions of a ppLasso or gr_ppLasso object — predict.ppLasso","text":"","code":"data(BinaryData) data <- BinaryData$data Y.char <- BinaryData$Y.char prov.char <- BinaryData$prov.char Z.char <- BinaryData$Z.char fit <- pp.lasso(data, Y.char, Z.char, prov.char) predict(fit, data, Z.char, prov.char, lambda = fit$lambda, type = \"response\")[1:10, 1:5] #>           0.132    0.1202    0.1096    0.0998     0.091 #>  [1,] 0.2874999 0.2996927 0.3106971 0.3206762 0.3297643 #>  [2,] 0.2051302 0.2112109 0.2163924 0.2208163 0.2246015 #>  [3,] 0.2051302 0.2191951 0.2321638 0.2441339 0.2551989 #>  [4,] 0.3947391 0.4208778 0.4449423 0.4671087 0.4875485 #>  [5,] 0.2345694 0.2340619 0.2330311 0.2316163 0.2299295 #>  [6,] 0.3188411 0.3744516 0.4280555 0.4786478 0.5256182 #>  [7,] 0.3924033 0.3836025 0.3752418 0.3673071 0.3597819 #>  [8,] 0.3658512 0.3870533 0.4065558 0.4245437 0.4411742 #>  [9,] 0.2298886 0.2256943 0.2215601 0.2175107 0.2135686 #> [10,] 0.3947391 0.4374814 0.4772352 0.5139266 0.5476058 predict(fit, data, Z.char, prov.char, lambda = 0.001, type = \"class\")[1:10] #>  [1] 1 0 0 1 0 1 0 1 0 1 predict(fit, data, Z.char, prov.char, lambda = 0.04, type = \"vars\") #> Z1 Z3 Z4  #>  1  3  4   data(BinaryData) data <- BinaryData$data Y.char <- BinaryData$Y.char prov.char <- BinaryData$prov.char Z.char <- BinaryData$Z.char group <- BinaryData$group fit <- grp.lasso(data, Y.char, Z.char, prov.char, group = group) predict(fit, data, Z.char, prov.char, lambda = fit$lambda, type = \"response\")[1:10, 1:5] #>          0.0939    0.0856     0.078     0.071    0.0647 #>  [1,] 0.2874998 0.2986935 0.3093832 0.3193357 0.3255634 #>  [2,] 0.2051288 0.2100619 0.2149546 0.2191076 0.2136753 #>  [3,] 0.2051288 0.2180235 0.2305894 0.2431181 0.2603558 #>  [4,] 0.3947376 0.4185762 0.4419123 0.4646744 0.4888233 #>  [5,] 0.2345683 0.2353836 0.2346598 0.2323132 0.2223927 #>  [6,] 0.3188407 0.3711201 0.4233544 0.4745208 0.5275946 #>  [7,] 0.3924044 0.3852951 0.3773617 0.3679648 0.3448889 #>  [8,] 0.3658529 0.3891889 0.4090002 0.4266957 0.4552054 #>  [9,] 0.2298861 0.2270617 0.2232482 0.2183580 0.2074687 #> [10,] 0.3947376 0.4344220 0.4731255 0.5103060 0.5458409 predict(fit, data, Z.char, prov.char, lambda = 0.001, type = \"class\")[1:10] #>  [1] 1 0 0 1 0 1 0 1 0 1 predict(fit, data, Z.char, prov.char, lambda = 0.04, type = \"vars\") #> Z1 Z2 Z3 Z4  #>  1  2  3  4  predict(fit, data, Z.char, prov.char, lambda = 0.04, type = \"groups\") #> [1] 1 2 #> Levels: 1 2 3"},{"path":"https://um-kevinhe.github.io/grplasso/reference/predict.strat_cox.html","id":null,"dir":"Reference","previous_headings":"","what":"Predictions of a strat_cox object — predict.strat_cox","title":"Predictions of a strat_cox object — predict.strat_cox","text":"Return model predictions strat_cox object","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/predict.strat_cox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predictions of a strat_cox object — predict.strat_cox","text":"","code":"# S3 method for class 'strat_cox' predict(   fit,   data,   Z.char,   lambda,   which = 1:length(fit$lambda),   type = c(\"link\", \"response\", \"vars\", \"nvars\", \"groups\", \"ngroups\"),   ... )"},{"path":"https://um-kevinhe.github.io/grplasso/reference/predict.strat_cox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predictions of a strat_cox object — predict.strat_cox","text":"fit strat_cox object. data dataframe list object contains variables prediction. Z.char names covariates data vector character strings. lambda values regularization parameter lambda predictions requested. values lambda sequence fitted models, linear interpolation used. indices penalty parameter lambda predictions required. default, indices returned. lambda specified, override . type type prediction: link: linear predictors response: risk (.e., exp(link)) vars: indices non-zero coefficients nvars: number non-zero coefficients groups: indices non-zero groups ngroups: number non-zero coefficients ...","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/predict.strat_cox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predictions of a strat_cox object — predict.strat_cox","text":"","code":"data(ContTime) data <- ContTime$data Event.char <- ContTime$Event.char prov.char <- ContTime$prov.char Z.char <- ContTime$Z.char Time.char <- ContTime$Time.char fit <- Strat.cox(data, Event.char, Z.char, Time.char, prov.char, group = c(1, 2, 2, 3, 3)) predict(fit, data, Z.char, lambda = fit$lambda, type = \"response\")[1:5, 1:5] #>      0.0394    0.0368    0.0343     0.032    0.0298 #> [1,]      1 0.9341802 0.8746803 0.8227072 0.7768418 #> [2,]      1 0.9461696 0.8968936 0.8533355 0.8144665 #> [3,]      1 0.8974894 0.8084036 0.7334456 0.6695674 #> [4,]      1 0.9530925 0.9098448 0.8713543 0.8367885 #> [5,]      1 0.8908210 0.7966337 0.7179336 0.6513011"},{"path":"https://um-kevinhe.github.io/grplasso/reference/Strat.cox.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a penalized stratified cox model — Strat.cox","title":"Fit a penalized stratified cox model — Strat.cox","text":"Main function fitting penalized stratified cox model.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/Strat.cox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a penalized stratified cox model — Strat.cox","text":"","code":"Strat.cox(   data,   Event.char,   Z.char,   Time.char,   prov.char,   group = 1:length(Z.char),   group.multiplier,   standardize = T,   lambda,   nlambda = 100,   lambda.min.ratio = 0.001,   lambda.early.stop = FALSE,   nvar.max = p,   group.max = length(unique(group)),   stop.loss.ratio = 0.001,   tol = 1e-04,   max.each.iter = 10000,   max.total.iter = (max.each.iter * nlambda),   actSet = TRUE,   actIter = max.each.iter,   actGroupNum = sum(unique(group) != 0),   actSetRemove = F,   returnX = FALSE,   trace.lambda = FALSE,   ... )"},{"path":"https://um-kevinhe.github.io/grplasso/reference/Strat.cox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a penalized stratified cox model — Strat.cox","text":"data dataframe list object contains variables model. Event.char name event indicator data character string. Event indicator binary variable 1 indicating event occurred 0 indicating (right) censoring. Z.char names covariates data vector character strings. Time.char name follow time data character string. prov.char name stratum indicator data character string. \"prov.char\" specified, observations considered stratum. group vector describing grouping coefficients. coefficients included model without penalized, assign group 0 (\"0\"). group.multiplier vector values representing multiplicative factors covariate's penalty multiplied. Default vector 1's. standardize logical flag x variable standardization, prior fitting model sequence. coefficients always returned original scale. Default standardize=TRUE. lambda user supplied lambda sequence. Typical usage program compute lambda sequence based nlambda lambda.min.ratio. nlambda number lambda values. Default 100. lambda.min.ratio fraction smallest value lambda lambda.max (smallest lambda coefficients zero) log scale. Default 1e-03. lambda.early.stop whether program stop running entire sequence lambda. Early stop based ratio deviance models two successive lambda. Default FALSE. nvar.max number maximum selected variables. Default number covariates. group.max number maximum selected groups. Default number groups. stop.loss.ratio lambda.early.stop = TRUE, ratio loss early stopping. Default 1e-3. tol convergence threshold. lambda, program stop maximum change covariate coefficient smaller tol. Default 1e-4. max..iter maximum number iterations lambda. Default 1e4. max.total.iter maximum number iterations entire path. Default max..iter * nlambda. actSet whether use active method variable selection. Default TRUE. actIter actSet = TRUE, maximum number iterations new updated active set. Default max..iter (.e. update current active set convergence ). actGroupNum actSet = TRUE, maximum number variables can selected new active set time active set updated. Default number groups. actSetRemove actSet = TRUE, whether remove zero coefficients current active set. Default FALSE. returnX whether return standardized design matrix. Default FALSE. trace.lambda whether display progress fitting entire path. Default FALSE. ... extra arguments passed function.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/Strat.cox.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a penalized stratified cox model — Strat.cox","text":"object S3 class strat_cox. beta fitted matrix covariate coefficients. number rows equal number coefficients, number columns equal nlambda. group vector describing grouping coefficients. lambda sequence lambda values path. loss likelihood fitted model value lambda. linear.predictors linear predictors fitted model value lambda. df estimates effective number selected variables points along regularization path. iter number iterations convergence value lambda.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/Strat.cox.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a penalized stratified cox model — Strat.cox","text":"model fit Newton method coordinate descent method.","code":""},{"path":"https://um-kevinhe.github.io/grplasso/reference/Strat.cox.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fit a penalized stratified cox model — Strat.cox","text":"K. , J. Kalbfleisch, Y. Li, et al. (2013) Evaluating hospital readmission rates dialysis facilities; adjusting hospital effects. Lifetime Data Analysis, 19: 490-512.","code":""},{"path":[]},{"path":"https://um-kevinhe.github.io/grplasso/reference/Strat.cox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a penalized stratified cox model — Strat.cox","text":"","code":"data(ContTime) data <- ContTime$data Event.char <- ContTime$Event.char prov.char <- ContTime$prov.char Z.char <- ContTime$Z.char Time.char <- ContTime$Time.char fit <- Strat.cox(data, Event.char, Z.char, Time.char, prov.char, group = c(1, 2, 2, 3, 3)) fit$beta[, 1:5] #>    0.0394      0.0368     0.0343       0.032      0.0298 #> Z1      0 -0.01983922 -0.0390155 -0.05686517 -0.07358008 #> Z2      0  0.00000000  0.0000000  0.00000000  0.00000000 #> Z3      0  0.00000000  0.0000000  0.00000000  0.00000000 #> Z4      0  0.00000000  0.0000000  0.00000000  0.00000000 #> Z5      0  0.00000000  0.0000000  0.00000000  0.00000000"}]
