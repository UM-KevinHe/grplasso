% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DiscSurv.R
\name{DiscSurv}
\alias{DiscSurv}
\title{Fit a penalized discrete survival model (without provider information)}
\usage{
DiscSurv(
  data,
  Event.char,
  Z.char,
  Time.char,
  lambda,
  nlambda = 100,
  lambda.min.ratio = 1e-04,
  penalize.x = rep(1, length(Z.char)),
  penalized.multiplier,
  lambda.early.stop = FALSE,
  nvar.max = p,
  stop.dev.ratio = 0.001,
  bound = 10,
  backtrack = FALSE,
  tol = 1e-04,
  max.each.iter = 10000,
  max.total.iter = (max.each.iter * nlambda),
  actSet = TRUE,
  actIter = max.each.iter,
  actVarNum = sum(penalize.x == 1),
  actSetRemove = F,
  returnX = FALSE,
  trace.lambda = FALSE,
  threads = 1,
  MM = FALSE,
  return.transform.data = FALSE,
  ...
)
}
\arguments{
\item{data}{an `dataframe` or `list` object that contains the variables in the model.}

\item{Event.char}{name of the event indicator in `data` as a character string.}

\item{Z.char}{names of covariates in `data` as vector of character strings.}

\item{Time.char}{name of the observation time in `data` as a character string.}

\item{lambda}{a user supplied lambda sequence. Typical usage is to have the program compute its own lambda sequence based on `nlambda` and `lambda.min.ratio`.}

\item{nlambda}{the number of lambda values. Default is 100.}

\item{lambda.min.ratio}{the fraction of the smallest value for lambda with `lambda.max` (smallest lambda for which all coefficients are zero) on log scale. Default is 1e-04.}

\item{penalize.x}{a vector indicates whether the corresponding covariate will be penalized. If equals 0, variable is unpenalized, else is penalized. Default is a vector of 1's (all covariates are penalized).}

\item{penalized.multiplier}{A vector of values representing multiplicative factors by which each covariate's penalty is to be multiplied. Default is a vector of 1's.}

\item{lambda.early.stop}{whether the program stop before running the entire sequence of lambda. Early stop based on the ratio of deviance for models under two successive lambda. Default is `FALSE`.}

\item{nvar.max}{number of maximum selected variables. Default is the number of all covariates.}

\item{stop.dev.ratio}{if `lambda.early.stop = TRUE`, the ratio of deviance for early stopping. Default is 1e-3.}

\item{bound}{a positive number to avoid inflation of provider effect. Default is 10.}

\item{backtrack}{for updating the provider effect, whether to use the "backtracking line search" with Newton method.}

\item{tol}{convergence threshold. For each lambda, the program will stop if the maximum change of covariate coefficient is smaller than `tol`. Default is 1e-4.}

\item{max.each.iter}{maximum number of iterations for each lambda. Default is 1e4.}

\item{max.total.iter}{maximum number of iterations for entire path. Default is `max.each.iter` * `nlambda`.}

\item{actSet}{whether to use the active method for variable selection. Default is TRUE.}

\item{actIter}{if `actSet = TRUE`, the maximum number of iterations for a new updated active set. Default is `max.each.iter` (i.e. we will update the current active set until convergence ).}

\item{actSetRemove}{if `actSet = TRUE`, whether we remove the zero coefficients from the current active set. Default is FALSE.}

\item{returnX}{whether return the standardized design matrix. Default is FALSE.}

\item{trace.lambda}{whether display the progress for fitting the entire path. Default is FALSE.}

\item{threads}{number of cores that are used for parallel computing.}

\item{MM}{whether we use the "Majorize-Minimization" algorithm to optimize the objective function.}

\item{...}{extra arguments to be passed to function.}
}
\value{
An object with S3 class \code{DiscSurv}.

\item{beta}{the fitted matrix of covariate coefficients.
The number of rows is equal to the number of coefficients,
and the number of columns is equal to nlambda.}

\item{alpha}{the fitted value of logit-transformed baseline hazard.}

\item{lambda}{the sequence of `lambda` values in the path.}

\item{df}{the estimates of effective number of selected variables all the points along the regularization path.}

\item{iter}{the number of iterations until convergence at each value of `lambda`.}
}
\description{
Main function for fitting a penalized discrete survival model without provider information
}
\details{
The model is fit by Newton method and coordinate descent method.
}
\examples{
data(Surv_Data)
data <- Surv_Data$data
Event.char <- Surv_Data$Event.char
Z.char <- Surv_Data$Z.char
Time.char <- Surv_Data$Time.char
fit <- DiscSurv(data, Event.char, Z.char, Time.char) # fit a discrete survival model without any given provider information.
fit$beta[, 1:5] # covariate coefficient
fit$alpha[, 1:5] #time effect

}
\references{
K. He, J. Kalbfleisch, Y. Li, and et al. (2013) Evaluating hospital readmission rates in dialysis facilities; adjusting for hospital effects.
\emph{Lifetime Data Analysis}, \strong{19}: 490-512.
\cr
}
\seealso{
\code{\link{coef}}, \code{\link{plot}} function.
}
