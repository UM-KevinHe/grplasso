% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ppLasso.R
\name{pp.lasso}
\alias{pp.lasso}
\title{fit a penalized generalized regression model}
\usage{
pp.lasso(
  data,
  Y.char,
  Z.char,
  prov.char,
  standardize = T,
  lambda,
  nlambda = 100,
  lambda.min.ratio = 1e-04,
  penalize.x = rep(1, length(Z.char)),
  penalized.multiplier,
  lambda.early.stop = FALSE,
  nvar.max = p,
  stop.dev.ratio = 0.001,
  bound = 10,
  backtrack = FALSE,
  tol = 1e-04,
  max.each.iter = 10000,
  max.total.iter = (max.each.iter * nlambda),
  actSet = TRUE,
  actIter = max.each.iter,
  actVarNum = sum(penalize.x == 1),
  actSetRemove = F,
  returnX = FALSE,
  trace.lambda = FALSE,
  threads = 1,
  MM = FALSE,
  ...
)
}
\arguments{
\item{data}{an `dataframe` or `list` object that contains the variables in the model.}

\item{Y.char}{name of the response variable in `data` as a character string.}

\item{Z.char}{names of covariates in `data` as vector of character strings.}

\item{prov.char}{name of provider IDs variable in `data` as a character string.}

\item{standardize}{logical flag for x variable standardization, prior to fitting the model sequence. The coefficients are always returned on the original scale. Default is `standardize=TRUE`.}

\item{lambda}{a user supplied lambda sequence. Typical usage is to have the program compute its own lambda sequence based on `nlambda` and `lambda.min.ratio`.}

\item{nlambda}{the number of lambda values. Default is 100.}

\item{lambda.min.ratio}{the fraction of the smallest value for lambda with `lambda.max` (smallest lambda for which all coefficients are zero) on log scale. Default is 1e-04.}

\item{penalize.x}{a vector indicates whether the corresponding covariate will be penalized. If equals 0, variable is unpenalized, else is penalized. Default is a vector of 1's (all covariates are penalized).}

\item{penalized.multiplier}{A vector of values representing multiplicative factors by which each covariate's penalty is to be multiplied. Default is a vector of 1's.}

\item{lambda.early.stop}{whether the program stop before running the entire sequence of lambda. Early stop based on the ratio of deviance for models under two successive lambda. Default is `FALSE`.}

\item{nvar.max}{number of maximum selected variables. Default is the number of all covariates.}

\item{stop.dev.ratio}{if `lambda.early.stop = TRUE`, the ratio of deviance for early stopping. Default is 1e-3.}

\item{bound}{a positive number to avoid inflation of provider effect. Default is 10.}

\item{backtrack}{for updating the provider effect, whether to use the "backtracking line search" with Newton method.}

\item{tol}{convergence threshold. For each lambda, the program will stop if the maximum change of covariate coefficient is smaller than `tol`. Default is 1e-4.}

\item{max.each.iter}{maximum number of iterations for each lambda. Default is 1e4.}

\item{max.total.iter}{maximum number of iterations for entire path. Default is `max.each.iter` * `nlambda`.}

\item{actSet}{whether to use the active method for variable selection. Default is TRUE.}

\item{actIter}{if `actSet = TRUE`, the maximum number of iterations for a new updated active set. Default is `max.each.iter` (i.e. we will update the current active set until convergence ).}

\item{actVarNum}{if `actSet = TRUE`, the maximum number of variables that can be selected into the new active set for each time when the active set is updated. Default is `nvar.max`.}

\item{actSetRemove}{if `actSet = TRUE`, whether we remove the zero coefficients from the current active set. Default is FALSE.}

\item{returnX}{whether return the standardized design matrix. Default is FALSE.}

\item{trace.lambda}{whether display the progress for fitting the entire path. Default is FALSE.}

\item{threads}{number of cores that are used for parallel computing.}

\item{MM}{whether we use the "Majorize-Minimization" algorithm to optimize the objective function.}

\item{...}{extra arguments to be passed to function.}
}
\value{
An object with S3 class `ppLasso`.

\item{beta}{the fitted matrix of covariate coefficients.
The number of rows is equal to the number of coefficients,
and the number of columns is equal to nlambda.}

\item{gamma}{the fitted value of provider effects.}

\item{lambda}{the sequence of `lambda` values in the path.}

\item{loss}{the loss of the fitted model at each value of `lambda`.}

\item{linear.predictors}{the linear predictors of the fitted model at each value of `lambda`.}

\item{df}{the estimates of effective number of selected variables all the points along the regularization path.}

\item{iter}{the number of iterations until convergence at each value of `lambda`.}
}
\description{
Fit a penalized generalized regression model via coordinate descent method:
}
\details{
The model is fit by Newton method and coordinate descent method.
}
\examples{
data(GLM_Data)
Y.char <- 'Y'
prov.char <- 'Prov.ID'
Z.char <- c("Z1", "Z2", "Z3", "Z4", "Z5")
fit <- pp.lasso(GLM_Data, Y.char, Z.char, prov.char)
# fitted values of covariate coefficients (under the lambda sequence that was automatically generated by the package).
round(fit$beta[1:5, 1:5], 5)
# estimated center effects
round(fit$gamma[1:5, 1:5], 5)

}
\references{
K. He, J. Kalbfleisch, Y. Li, and et al. (2013) Evaluating hospital readmission rates in dialysis facilities; adjusting for hospital effects.
\emph{Lifetime Data Analysis}, \strong{19}: 490-512.
\cr
}
\seealso{
\code{\link{coef}} function.
}
