% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pp_DiscSurv.R
\name{pp.DiscSurv}
\alias{pp.DiscSurv}
\title{Fit a penalized discrete survival model}
\usage{
pp.DiscSurv(
  data,
  Event.char,
  prov.char,
  Z.char,
  Time.char,
  lambda,
  nlambda = 100,
  lambda.min.ratio = 1e-04,
  penalize.x = rep(1, length(Z.char)),
  penalized.multiplier,
  lambda.early.stop = FALSE,
  nvar.max = p,
  stop.dev.ratio = 0.001,
  bound = 10,
  backtrack = FALSE,
  tol = 1e-04,
  max.each.iter = 10000,
  max.total.iter = (max.each.iter * nlambda),
  actSet = TRUE,
  actIter = max.each.iter,
  actVarNum = sum(penalize.x == 1),
  actSetRemove = F,
  returnX = FALSE,
  trace.lambda = FALSE,
  threads = 1,
  MM = FALSE,
  return.transform.data = FALSE,
  ...
)
}
\arguments{
\item{data}{an \code{dataframe} or \code{list} object that contains the variables in the model.}

\item{Event.char}{name of the event indicator in \code{data} as a character string. Event indicator should be a
binary variable with 1 indicating that the event has occurred and 0 indicating (right) censoring.}

\item{prov.char}{name of provider IDs variable in \code{data} as a character string.}

\item{Z.char}{names of covariates in \code{data} as vector of character strings.}

\item{Time.char}{name of the follow up time in \code{data} as a character string.}

\item{lambda}{a user supplied lambda sequence. Typical usage is to have the program compute its own lambda sequence based on \code{nlambda} and \code{lambda.min.ratio}.}

\item{nlambda}{the number of lambda values. Default is 100.}

\item{lambda.min.ratio}{the fraction of the smallest value for lambda with \code{lambda.max} (smallest lambda for which all coefficients are zero) on log scale. Default is 1e-04.}

\item{penalize.x}{a vector indicates whether the corresponding covariate will be penalized. If equals 0, variable is unpenalized, else is penalized. Default is a vector of 1's (all covariates are penalized).}

\item{penalized.multiplier}{A vector of values representing multiplicative factors by which each covariate's penalty is to be multiplied. Default is a vector of 1's.}

\item{lambda.early.stop}{whether the program stop before running the entire sequence of lambda. Early stop based on the ratio of deviance for models under two successive lambda. Default is \code{FALSE}.}

\item{nvar.max}{number of maximum selected variables. Default is the number of all covariates.}

\item{stop.dev.ratio}{if \code{lambda.early.stop = TRUE}, the ratio of deviance for early stopping. Default is 1e-3.}

\item{bound}{a positive number to avoid inflation of provider effect. Default is 10.}

\item{backtrack}{for updating the provider effect, whether to use the "backtracking line search" with Newton method.}

\item{tol}{convergence threshold. For each lambda, the program will stop if the maximum change of covariate coefficient is smaller than \code{tol}. Default is 1e-4.}

\item{max.each.iter}{maximum number of iterations for each lambda. Default is 1e4.}

\item{max.total.iter}{maximum number of iterations for entire path. Default is \code{max.each.iter} * \code{nlambda}.}

\item{actSet}{whether to use the active method for variable selection. Default is TRUE.}

\item{actIter}{if \code{actSet = TRUE}, the maximum number of iterations for a new updated active set. Default is \code{max.each.iter} (i.e. we will update the current active set until convergence ).}

\item{actSetRemove}{if \code{actSet = TRUE}, whether we remove the zero coefficients from the current active set. Default is FALSE.}

\item{returnX}{whether return the standardized design matrix. Default is FALSE.}

\item{trace.lambda}{whether display the progress for fitting the entire path. Default is FALSE.}

\item{threads}{number of cores that are used for parallel computing.}

\item{MM}{whether we use the "Majorize-Minimization" algorithm to optimize the objective function.}

\item{...}{extra arguments to be passed to function.}
}
\value{
An object with S3 class \code{ppDiscSurv}.

\item{beta}{the fitted matrix of covariate coefficients.
The number of rows is equal to the number of coefficients,
and the number of columns is equal to nlambda.}

\item{alpha}{the fitted value of logit-transformed baseline hazard.}

\item{gamma}{the fitted value of provider effects. The effect of the first provider is set to be reference group.}

\item{lambda}{the sequence of \code{lambda} values in the path.}

\item{df}{the estimates of effective number of selected variables all the points along the regularization path.}

\item{iter}{the number of iterations until convergence at each value of \code{lambda}.}
}
\description{
Main function for fitting a penalized discrete survival model
}
\details{
The model is fit by Newton method and coordinate descent method.
}
\examples{
data(DiscTime)
data <- DiscTime$data
Event.char <- DiscTime$Event.char
prov.char <- DiscTime$prov.char
Z.char <- DiscTime$Z.char
Time.char <- DiscTime$Time.char
fit <- pp.DiscSurv(data, Event.char, prov.char, Z.char, Time.char)
fit$beta[, 1:5]
fit$alpha[, 1:5]
fit$gamma[, 1:5] #effect of the first provider is set to be zero

}
\references{
K. He, J. Kalbfleisch, Y. Li, and et al. (2013) Evaluating hospital readmission rates in dialysis facilities; adjusting for hospital effects.
\emph{Lifetime Data Analysis}, \strong{19}: 490-512.
\cr
}
\seealso{
\code{\link{coef}}, \code{\link{plot}} function.
}
