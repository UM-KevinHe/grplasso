% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict.R
\name{predict.ppLasso}
\alias{predict.ppLasso}
\alias{predict.gr_ppLasso}
\title{predictions of a ppLasso or gr_ppLasso object}
\usage{
\method{predict}{ppLasso}(
  fit,
  data,
  Z.char,
  prov.char,
  lambda,
  which = 1:length(fit$lambda),
  type = c("response", "class", "vars", "nvars"),
  ...
)

\method{predict}{gr_ppLasso}(
  fit,
  data,
  Z.char,
  prov.char,
  lambda,
  which = 1:length(fit$lambda),
  type = c("response", "class", "vars", "groups", "nvars", "ngroups", "beta.norm"),
  ...
)
}
\arguments{
\item{fit}{a \code{ppLasso} or \code{gr_ppLasso} or \code{ppDiscSurv} object.}

\item{data}{an `dataframe` or `list` object that contains the variables for prediction.}

\item{Z.char}{names of covariates in `data` as vector of character strings.}

\item{prov.char}{name of provider IDs variable in `data` as a character string.}

\item{lambda}{values of the regularization parameter lambda at which predictions are requested. For values of lambda not in the sequence of fitted models, linear interpolation is used.}

\item{which}{indices of the penalty parameter lambda at which predictions are required. By default, all indices are returned. If lambda is specified, this will override which.}

\item{type}{type of prediction: \code{response} provides the fitted value; \code{class} returns the binomial outcome with the largest probability;
\code{vars} returns the indices for the non-zero coefficients; \code{nvars} returns the number of non-zero coefficients;
\code{groups} returns the indices for the non-zero groups; \code{ngroups} returns the number of non-zero coefficients;
\code{beta.norm} returns L2 norm of the coefficients in each group}

\item{...}{}

\item{Y.char}{name of the response variable in `data` as a character string.}
}
\description{
return the model predictions of a \code{ppLasso} or \code{gr_ppLasso} object
}
\examples{
data(GLM_Data)
Y.char <- 'Y'
prov.char <- 'Prov.ID'
Z.char <- c("Z1", "Z2", "Z3", "Z4", "Z5")
fit <- pp.lasso(GLM_Data, Y.char, Z.char, prov.char)
predict(fit, GLM_Data, Z.char, prov.char, lambda = fit$lambda, type = "response")[1:10, 1:5]
predict(fit, GLM_Data, Z.char, prov.char, lambda = 0.001, type = "class")[1:10]
predict(fit, GLM_Data, Z.char, prov.char, lambda = 0.04, type = "vars")

data(GLM_Data)
Y.char <- 'Y'
prov.char <- 'Prov.ID'
Z.char <- c("Z1", "Z2", "Z3", "Z4", "Z5")
group <- c(1, 1, 2, 2, 3)
fit <- grp.lasso(GLM_Data, Y.char, Z.char, prov.char, group = group)
predict(fit, GLM_Data, Z.char, prov.char, lambda = fit$lambda, type = "response")[1:10, 1:5]
predict(fit, GLM_Data, Z.char, prov.char, lambda = 0.001, type = "class")[1:10]
predict(fit, GLM_Data, Z.char, prov.char, lambda = 0.04, type = "vars")
predict(fit, GLM_Data, Z.char, prov.char, lambda = 0.04, type = "groups")
}
